package monotonicstack

// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
//
// 示例 1：
//
// 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
// 输出：6
// 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
//
// 示例 2：
//
// 输入：height = [4,2,0,3,2,5]
// 输出：9
//
// 提示：
//
// n == height.length
// 1 <= n <= 2 * 10⁴
// 0 <= height[i] <= 10⁵
func trap(height []int) int {
	var res int
	st := []int{0}
	for i := 1; i < len(height); i++ {
		if height[i] == height[st[len(st)-1]] {
			st = st[:len(st)-1]
		} else {
			for len(st) > 0 && height[i] > height[st[len(st)-1]] {
				right, mid := i, st[len(st)-1]
				st = st[:len(st)-1]
				if len(st) == 0 {
					break
				}
				left := st[len(st)-1]
				res += (right - left - 1) * (min(height[left], height[right]) - height[mid])
			}
		}
		st = append(st, i)
	}
	return res
}

/**
思路：
计算可接雨水面积 -> 计算凹槽面积 -> 计算左侧&右侧更高的元素
	-> 高 = min(左侧高, 右侧高) - 中间高；宽 = 右侧位置 - 左侧位置 - 1
	-> 面积 = 长 * 宽

需要找更高的元素 -> 梯度递增的单调栈
	-> 当前元素 < 栈口元素：入栈

	-> 当前元素 > 栈口元素：找到了右侧更高的元素，即找到了一个凹槽，可以计算雨水面积。
	   右侧柱子right = 当前元素
	   中间柱子mid = 栈口元素
	   左侧柱子left = 栈口的后一个元素。如果栈内元素不足2个，凑不齐3根柱子，则跳过本轮运算。因为要求只计算柱子间的雨水。
	   计算完当前面积后，将mid弹出。再循环比较right和此时的栈口元素left。
	   如果又出现了凹槽，则left作为mid，left后一个元素作为新的left，跟right一起组成3个柱子，计算雨水面积。
	   直到right小于栈口元素，则将right入栈，作为栈口元素mid，等待与可能的右侧柱子组成下一个凹槽。
	   整体思路就是，在右移右边界的过程中，不断检查是否有新的凹槽；处理完当前凹槽后，尝试向左检查元素作为中间柱子，再看是否有新的凹槽。

	-> 当前元素 == 栈口元素：有两种处理方式。举例[5, 5, 1, 7]
	   1. 直接入栈
		  计算完1作为中间柱子的场景后，1弹出。
   		  [5, 5, 7]会被作为凹槽处理，但高=min(5, 7)-5=0会导致计算结果为0，不影响最终面积。但会多一次冗余处理；
	   2. 先弹出栈口元素，再将当前元素入栈。
		  将index=0的5替换为index=1的5，更新左边界。
		  因为到最终计算凹槽面积时，左侧柱高相同的情况下，一定是最右的柱子跟中间、右边形成凹槽，参与计算。
		  注意不能直接continue忽略当前元素，否则无法更新左边界。
*/

package dynamicprogramming

// 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
//
// 示例 1：
//
// 输入：n = 3
// 输出：5
//
// 示例 2：
//
// 输入：n = 1
// 输出：1
//
// 提示：
//
// 1 <= n <= 19
func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0] = 1
	for i := 1; i <= n; i++ {
		for r := 1; r <= i; r++ {
			dp[i] += dp[r-1] * dp[i-r]
		}
	}
	return dp[n]
}

/**
先分析base case：
n = 0：1种
根节点为空，可以是二叉搜索树 / 满二叉树等任意二叉树；

n = 1：1种，只有一个叶子节点；
1

n = 2：2种
1                2
  \            /
    2        1

再来枚举当n = 3时，共有几种不同的二叉搜索树：
当以1为根节点时，
1                          1
  \                           \
    2                           3
      \                       /
        3                  2
左右子树分布的情况(忽略数值)与n=2时一致；

当以2为根节点时，
    2
  /   \
 1     3
左右子树分布的情况(忽略数值)与n=1时一致；

当以3为根节点时，
    3                3
  /                /
1                2
  \            /
    2        1
左右子树分布的情况(忽略数值)与n=2时一致。

由此可推导，n个数可组成的二叉搜索树种类，依赖于<n个数组成总数的结果。

DP数组及下标的含义：
- i：从1到i，i个不同的元素范围；
- dp[i]：能够组成的不同的二叉搜索树种数；
递推公式：
假设以r(root)作为根节点，r将[1, i]递增序列切割为左子树[1, r-1]及右子树[r+1, i]，
那么能够组成的二叉搜索树种数就是【左子树的所有可能】*【右子树的所有可能】。
枚举不同的根节点，结果即为他们的和。
for r range [1, i]
dp[i] = dp[i] + dp[r-1] * dp[i-r]
初始化：由base case可得，dp[0] = 1，dp[1] = 1；
遍历顺序：由于后面的计算结果依赖于前面的，故从左往右。
*/

/**
二叉搜索树 vs 二叉树对此题的影响
由于二叉搜索树的中序遍历是单调递增的，所以固定根节点后，左右子树的范围被划分为2个子集，
左子树的值均小于根节点，右子树的值均大于根节点，严格遵循二叉搜索树的定义，且子树的形态是明确、可枚举的。
如果是普通二叉树，固定根节点后，左右子树依然有各种可能，
无法达到"将原问题分解为相互重叠的子问题，并且每个子问题的解是最优的，这些子问题的最优解能够组合成原问题的最优解"的效果。
这也是动态规划的核心思想。
*/

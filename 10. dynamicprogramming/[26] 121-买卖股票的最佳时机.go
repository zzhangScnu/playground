package dynamicprogramming

// 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
//
// 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
//
// 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
//
// 示例 1：
//
// 输入：[7,1,5,3,6,4]
// 输出：5
// 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
//
//	注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
//
// 示例 2：
//
// 输入：prices = [7,6,4,3,1]
// 输出：0
// 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
//
// 提示：
//
// 1 <= prices.length <= 10⁵
// 0 <= prices[i] <= 10⁴
func maxProfit(prices []int) int {
	n := len(prices)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, 2)
	}
	dp[0][0], dp[0][1] = 0, -prices[0]
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][1]+prices[i], dp[i-1][0])
		dp[i][1] = max(-prices[i], dp[i-1][1])
	}
	return dp[n-1][0]
}

/**
DP数组及下标含义：
- i：第i天；
- j：1/0，持有/不持有股票；
- dp[i][0]：第i天不持有股票能获得的最大利润；
- dp[i][1]：第i天持有股票能获得的最大利润。
注意，这里是持有，而不是买/卖。因为在某天可能不做买卖操作，所以用持有与否来表达所有可能的状态：
1. 若持有，可能当天买，也可能是之前买的，当天只是保持持有；
2. 若不持有，可能当天卖，也可能是之前卖的，当天只是保持不持有。

递推公式：
第i天不持有的最大利润：
1. 可能是之前持有，今天卖出：dp[i-1][1] + prices[i]；
2. 可能是之前不持有，今天保持不持有：dp[i-1][0]。
dp[i][0] = max(dp[i-1][1] + prices[i], dp[i-1][0])
第i天持有的最大利润：
1. 可能是之前不持有，今天买入：dp[i-1][0] - prices[i]；
2. 可能是之前持有，今天保持持有：dp[i-1][1]。
dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])
由于只能买入一次和卖出一次，在买入时，利润一定为0，即【dp[i-1][0] - prices[i]】可以简化为【- prices[i]】，则
dp[i][1] = max(-prices[i], dp[i-1][1])

最后返回的是dp[len(prices)-1][0]，因为最后卖出不持有的利润一定比抓在手上高。

初始化：
可以看出，第i天的利润依赖于[0...i-1]天的利润。
将dp[0][0]和dp[0][1]初始化即可。保持默认值。

遍历方向：
按日期从左到右遍历。
*/

/**
如何保证只能买入一次：
之前不持有 + 今天买入的状态方程为：-prices[i]
每次买入都基于本金为0，而不是依赖于之前已经赚取的利润。

如何保证只能卖出一次：
状态转移的单向性。
之前持有 + 今天卖出的状态方程为：dp[i][0] = max(dp[i-1][1] + prices[i], ...)
卖出操作只能发生在持有状态1，一旦卖出，持有状态由1转移为0，不在状态1则无法卖出，限制了多次卖出。
除非0再次转移为1，即有买入操作。
但买入操作排除了用状态0即卖出利润多次买入的可能性，被限制了只能进行一次，
故卖出也只能进行一次。
*/

package dynamicprogramming

/**
有一个容量为W的背包和n个物品，每个物品有两个属性:重量Wi和价值vi(i=1，2，...)
对于每个物品，你只能选择放入背包或者不放入背包(即"0-1"选择，要么选，要么不选，不能只选一部分)。
目标是在不超过背包容量的前提下，选择一些物品放入背包，使得青背包中物品的总价值最大。
*/

// Knapsack 函数用于解决 0 - 1 背包问题
// 参数 W 表示背包的容量
// 参数 weights 是一个切片，存储每个物品的重量
// 参数 values 是一个切片，存储每个物品的价值
// 返回值为在不超过背包容量的前提下能获得的最大价值
func Knapsack(W int, weights []int, values []int) int {
	n := len(weights)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, W)
	}
	for j := 0; j < W; j++ {
		if j >= weights[0] {
			dp[0][j] = values[0]
		}
	}
	for i, value := range values {
		for j, weight := range weights {
			dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight]+value)
		}
	}
	return dp[n][W]
}

/**
暴力解法
对于每个物品i，枚举取/不取两种情况，计算所有组合得到的总价值，取最大。
时间复杂度为O(n2)。
*/

/**
DP数组及下标的含义：
需要一个二维数组表达。因为有物品和背包两个维度。
- i：对[0...i]个物品，每个物品取或不取的某种排列；
- j：背包的剩余容量；
- dp[i][j]：对[0...i]个物品任意取且背包剩余容量为j时，能得到的最大总价值。

递推公式：
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + values[i])
当背包剩余容量为j时，物品i只有2种状态：
不取：当前总价值 = [0...i-1]的物品任意取所得到的最大总价值；
取：当前总价值 = 【空出weight[i]的容量后，[0...i-1]的物品任意取所得到的最大总价值】 + 【物品i的价值】
    其中，为什么是"空出weight[i]的容量"，而不是更多的容量？
	个人理解是，只考虑当前情况，至少能放下物品i即可，多余的容量并不会对总价值产生正向贡献。
两者取较大值。

初始化：
推导方向：
代入i=1，j=1可得：
dp[1][1] = max(dp[0][1], dp[0][1-weight[1]] + values[1])
可知，
dp[0][1] -> 正上方
dp[0][1-weight[1]] -> 左上角
也就是由上方和左方两个方向共同推导出当前值。

初始化对求结果的影响：
只有第0行和第0列会真实影响后面的值的推导，其他单元格的值会在推导过程中被覆盖。
所以其他单元格不显式初始化或赋为任何值都可以。
第一列dp[0...n][0]表示，第[0...i]个物品放进剩余容量为0的背包的最大总价值。可知放不下，只能为0；
第一行dp[0][0...W]表示，第0个物品放入容量分别为[0...W]个背包的最大总价值。可知如果能放下，就是物品0的价值；否则为0。

遍历方向：
两个for循环是否可以颠倒？
遍历方式1：先物品，再背包 -> 先遍历行，固定行再遍历列
遍历方式2：先背包，再物品 -> 先遍历列，固定列再遍历行
这两种方式，实际上都可以依赖左方和上方已经正确初始化的值推导出某个单元格的结果，所以无论哪种都可以。
*/

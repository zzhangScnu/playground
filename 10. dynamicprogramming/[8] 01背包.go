package dynamicprogramming

/**
有一个容量为W的背包和n个物品，每个物品有两个属性:重量Wi和价值vi(i=1，2，...)
对于每个物品，你只能选择放入背包或者不放入背包(即"0-1"选择，要么选，要么不选，不能只选一部分)。
目标是在不超过背包容量的前提下，选择一些物品放入背包，使得青背包中物品的总价值最大。
*/

// Knapsack 函数用于解决 0 - 1 背包问题
// 参数 W 表示背包的容量
// 参数 weights 是一个切片，存储每个物品的重量
// 参数 values 是一个切片，存储每个物品的价值
// 返回值为在不超过背包容量的前提下能获得的最大价值
func Knapsack(W int, weights []int, values []int) int {
	n := len(weights)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, W+1)
	}
	for j := weights[0]; j <= W; j++ {
		dp[0][j] = values[0]
	}
	for i := 1; i < n; i++ {
		for j := 1; j <= W; j++ {
			if j < weights[i] {
				dp[i][j] = dp[i-1][j]
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]]+values[i])
			}
		}
	}
	return dp[n-1][W]
}

/**
0-1背包：
某件物品只有0或1个。
完全背包：
某件物品有无数个，可以重复选取。

暴力解法
对于每个物品i，枚举取/不取两种情况，计算所有组合得到的总价值，取最大。
时间复杂度为O(n2)。
*/

/**
DP数组及下标的含义：
需要一个二维数组表达。因为有物品和背包两个维度。
手工代入样例填写一下表格，可得：
- i：对[0...i]个物品，每个物品取或不取的某种排列；
- j：背包容量；
- dp[i][j]：对[0...i]个物品任意取且背包容量为j时，能得到的最大总价值。

递推公式：
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + values[i])
当背包容量为j时，物品i只有2种状态：
不取：当前总价值 = [0...i-1]的物品任意取所得到的最大总价值；
取：当前总价值 = 【空出weight[i]的容量后，[0...i-1]的物品任意取所得到的最大总价值】 + 【物品i的价值】
    其中，为什么是"空出当前物品的容量"，而不是更多的容量？
	个人理解是，只考虑当前情况，至少能放下物品i即可，多余的容量并不会对总价值产生正向贡献。
两者取较大值。

初始化：
推导方向：
代入i=1，j=1可得：
dp[1][1] = max(dp[0][1], dp[0][1-weight[1]] + values[1])
可知，
dp[0][1] -> 正上方
dp[0][1-weight[1]] -> 左上角
也就是由上方和左方两个方向共同推导出当前值。

初始化对求结果的影响：
只有第0行和第0列会真实影响后面的值的推导，其他单元格的值会在推导过程中被覆盖。
所以其他单元格不显式初始化或赋为任何值都可以。
第一列dp[0...n][0]表示，第[0...i]个物品放进容量为0的背包的最大总价值。可知放不下，只能为0；
第一行dp[0][0...W]表示，第0个物品放入容量分别为[0...W]个背包的最大总价值。可知如果能放下，就是物品0的价值；否则为0。

遍历方向：
两个for循环是否可以颠倒？
遍历方式1：先物品，再背包 -> 先遍历行，固定行再遍历列
遍历方式2：先背包，再物品 -> 先遍历列，固定列再遍历行
这两种方式，实际上都可以依赖左方和上方已经正确初始化的值推导出某个单元格的结果，所以无论哪种都可以。
*/

/**
代码上的几个注意点：
1. DP数组初始化的行长度为W+1，因为求的是[0...W]；
2. 由于dp[0][0]都初始化过了，避免重复计算，直接从i=1和j=1开始即可；
3. 如果当前背包容量装不下当前物品，就继承取/不取前一个物品后背包的最大价值；
4.最后return的是dp[n-1][W]，注意n个物品的下标是[0...n-1]。
*/

/**
不同的应用场景：
纯0-1背包：所能得到的最大价值；
分割等和子集：是否能装满；
最后一块石头的重量：实际能装多少重量；
目标和：有多少不同的装法；
一和零：能装多少个。
*/

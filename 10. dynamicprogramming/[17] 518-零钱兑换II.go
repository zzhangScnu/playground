package dynamicprogramming

// 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
//
// 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
//
// 假设每一种面额的硬币有无限个。
//
// 题目数据保证结果符合 32 位带符号整数。
//
// 示例 1：
//
// 输入：amount = 5, coins = [1, 2, 5]
// 输出：4
// 解释：有四种方式可以凑成总金额：
// 5=5
// 5=2+2+1
// 5=2+1+1+1
// 5=1+1+1+1+1
//
// 示例 2：
//
// 输入：amount = 3, coins = [2]
// 输出：0
// 解释：只用面额 2 的硬币不能凑成总金额 3 。
//
// 示例 3：
//
// 输入：amount = 10, coins = [10]
// 输出：1
//
// 提示：
//
// 1 <= coins.length <= 300
// 1 <= coins[i] <= 5000
// coins 中的所有值 互不相同
// 0 <= amount <= 5000
func change(amount int, coins []int) int {
	dp := make([]int, amount+1)
	dp[0] = 1
	for i := 0; i < len(coins); i++ {
		for j := coins[i]; j <= amount; j++ {
			dp[j] += dp[j-coins[i]]
		}
	}
	return dp[amount]
}

/**
使用一组硬币候选集去凑一个金额，且每个硬币数量都是无限的，即可以选多次，是典型的完全背包问题。
硬币候选集 -> 物品；
需要凑的金额 -> 背包容量。

DP数组及下标含义：
j：背包容量为j，[0, amount]；
dp[j]：背包容量为j时，能够装满背包的硬币组合数。即凑成金额j有多少种不同的方式。

递推公式：
dp[j] += dp[j-coins[i]]+1

初始化：
dp[0] = 1：当背包容量为0时，组合数为1，即有一种方式装满。
其余单元格：保持0作为默认值即可，因为最终会被推导结果覆盖。

遍历方向：
物品和背包都是从左到右；且两者间的遍历顺序可以颠倒。
*/

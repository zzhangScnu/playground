package dynamicprogramming

// 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
//
// 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
//
// 假设每一种面额的硬币有无限个。
//
// 题目数据保证结果符合 32 位带符号整数。
//
// 示例 1：
//
// 输入：amount = 5, coins = [1, 2, 5]
// 输出：4
// 解释：有四种方式可以凑成总金额：
// 5=5
// 5=2+2+1
// 5=2+1+1+1
// 5=1+1+1+1+1
//
// 示例 2：
//
// 输入：amount = 3, coins = [2]
// 输出：0
// 解释：只用面额 2 的硬币不能凑成总金额 3 。
//
// 示例 3：
//
// 输入：amount = 10, coins = [10]
// 输出：1
//
// 提示：
//
// 1 <= coins.length <= 300
// 1 <= coins[i] <= 5000
// coins 中的所有值 互不相同
// 0 <= amount <= 5000
func change(amount int, coins []int) int {
	dp := make([]int, amount+1)
	dp[0] = 1
	for i := 0; i < len(coins); i++ {
		for j := coins[i]; j <= amount; j++ {
			dp[j] += dp[j-coins[i]]
		}
	}
	return dp[amount]
}

/**
使用一组硬币候选集去凑一个金额，且每个硬币数量都是无限的，即可以选多次，是典型的完全背包问题。
硬币候选集 -> 物品，且重量 == 价值；
需要凑的金额 -> 背包容量。

二维数组实现：
DP数组及下标含义：
i：对物品i取/不取，[0, len(coins)-1]；
j：背包容量为j，[0, amount]；
dp[i][j]：对物品i取/不取且当前背包容量为j时，有多少种方式可以装满背包。及有多少种硬币组合数可以凑成总金额amount。

递推公式：
dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]
不取i：dp[i-1][j]
取i：dp[i][j-coins[i]]
则对于当前物品i，凑成容量j的方式就是两者之和。
同样，跟0/1背包的区别是，取i之后还能继续取i，所以取i的硬币组合数是dp[i][j-coins[i]]，而不是排除本次的i的i-1。

推导方向：
可以看出由【正上】和【正左】推出当前值。

初始化：
由推导方向，可知需要初始化第一行和第一列的值。
第一列：背包容量为0，有一种方式可以装满，即什么也不装；
第一行：当背包容量 >= 物品0的重量时，可以无限重复装。
*/

/**
这里需要额外注意，题目中求的是【组合】还是【排列】。
组合：(1, 2)和(2, 1)是同一个组合，即不考虑元素先后顺序。
这时候需要先遍历物品，再遍历背包。
如外层循环固定物品1时，内层循环逐一尝试背包的每个容量；
下一轮外层循环固定物品2时，内层循环再次逐一尝试背包的每个容量。此时背包中可能已经放置了物品1了，且2的出现永远在1之后，所以只会有(1, 2)一种结果；

排列：(1, 2)和(2, 1)是不同的排列，即要考虑元素先后顺序。
这时候需要边遍历背包，再遍历物品。
如外层循环固定背包容量1时，内层循环逐一尝试每个物品。这时候可能会有(), (1), (2)等；
下一轮外层循环固定背包容量2时，内层循环再次逐一尝试每个物品。这时候就有可能出现(1, 2)和(2, 1)了。
*/

/**
一维数组实现：

DP数组及下标含义：
j：背包容量为j，[0, amount]；
dp[j]：背包容量为j时，能够装满背包的硬币组合数。即凑成金额j有多少种不同的方式。

递推公式：
dp[j] += dp[j-coins[i]]

初始化：
dp[0] = 1：当背包容量为0时，组合数为1，即有一种方式装满。
其余单元格：保持0作为默认值即可，因为最终会被推导结果覆盖。

遍历方向：
物品和背包都是从左到右；且两者间的遍历顺序可以颠倒。
*/

/**
最开始写的
for j := 0; j <= amount; j++ {
	if j >= coins[i] {
		dp[j] += dp[j-coins[i]] + 1
	}
}
等价于
for j := coins[i]; j <= amount; j++ {
	dp[j] += dp[j-coins[i]]
}
*/

// todo：剪枝？
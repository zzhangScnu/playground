有几道题从题意到解题思路都比较相似，分别是：

- 300.最长递增子序列：结果不要求连续、单个候选序列
- 674.最长连续递增序列：结果要求连续、单个候选序列
- 718.最长重复子数组：结果要求连续、两个候选序列
- 1143.最长公共子序列：结果不要求连续、两个候选序列

从题解来看，大致有两种方式：
1. 不断尝试更新全局最大变量res，最后返回res；
2. 不断累加dp数组，最后返回dp最末位置的值。

造成这种差异的根本原因是：
1. 结果是否要求连续：
    - 若要求连续：则在遍历过程中一旦不满足条件，则需清零dp值并从头计数。结果可能出现在中间。所以需要res来临时存储可能的结果；
    - 若不要求连续：则在遍历过程中dp值是逐渐累加的。结果一定出现在末尾。所以最末位位置的值一定是最大的，直接返回即可。
2. dp携带的是全局/局部信息：
    - 若携带全局信息：如1143的`dp[i][j]`，表达的是以i位置结尾的text1和以j位置结尾的text2中的最长公共子序列的长度，已经涵盖了所有可能的情况；
    - 若携带局部信息：如300的`dp[i]`，表达的是以nums[i]结尾的递增子序列的最长长度，而递推公式限制了仅能携带局部信息：
    ```
   	for i := 1; i < n; i++ {
		for j := 0; j < i; j++ {
			if nums[i] > nums[j] {
				dp[i] = max(dp[i], dp[j]+1)
			}
		}
		if dp[i] > res {
			res = dp[i]
		}
	}
    ```
    但如下做法也行不通：
    如果改变一下dp数组的含义为"遍历到nums[i]时序列[0...nums[i]]中最长递增子序列的长度"，再改一下递推公式，就能携带全局信息，此时能直接返回最末位置的dp值：
    ```
   	for i := 1; i < n; i++ {
		for j := 0; j < i; j++ {
			if nums[i] > nums[j] {
				dp[i] = max(dp[i], dp[j]+1)
			} else {
				dp[i] = max(dp[i], dp[j])
			}
		}
	}
    ```
    因为当nums[i] <= nums[j]时，dp[i]不能简单地继承dp[j]的值。当前元素nums[i]并不能接在nums[j]后面形成递增子序列。
    这样会导致dp[i]被错误地更新为前面某个较大的dp值。
    而实际上此时应该保持之前的dp[i]值。但由于初始化问题，dp[i]此时为0，所以无法得到正确的最大值。

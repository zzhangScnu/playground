package dynamicprogramming

// 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
//
// 回文字符串 是正着读和倒过来读一样的字符串。
//
// 子字符串 是字符串中的由连续字符组成的一个序列。
//
// 示例 1：
//
// 输入：s = "abc"
// 输出：3
// 解释：三个回文子串: "a", "b", "c"
//
// 示例 2：
//
// 输入：s = "aaa"
// 输出：6
// 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
//
// 提示：
//
// 1 <= s.length <= 1000
// s 由小写英文字母组成
func countSubstrings(s string) int {
	n := len(s)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, n)
	}
	var res int
	for i := n - 1; i >= 0; i-- {
		for j := i; j < n; j++ {
			if s[i] != s[j] {
				continue
			}
			if j-i <= 1 || dp[i+1][j-1] == 1 {
				dp[i][j] = 1
				res++
			}
		}
	}
	return res
}

/**
当s[i] == s[j]时，如果s[i+1...j-1]是回文串，则s[i...j]也是回文串。


DP数组及下标含义：
- i：s的子字符串的起始位置；
- j：s的子字符串的结束位置；
- dp[i][j]：s[i...j]是否回文串。
由定义可知，i <= j。

递推公式：
当s[i] == s[j]时：
1. 当len(s) == 1：是回文串，dp[i][j] = true，res++；
2. 当len(s) == 2：是回文串，dp[i][j] = true，res++；
   以上两步处理是为了满足i <= j的定义，避免数组越界。
3. 当len(s) > 2：如果dp[i+1][j-1] == true，dp[i][j] = true，res++。
最终返回res。
注意，由定义可知，i <= j，所以j从i开始进行遍历即可。

初始化：
将dp值全部初始化为false，这样就无需处理s[i] != s[j]的场景了。

遍历方向：
由[i+1][j-1]推导出[i][j]，可以看出是左下角 -> 右上角。
所以需要从下至上遍历i，从左到右遍历j。
*/

/**
一开始定义为如下，但其实找不到dp间的递推关系。

DP数组及下标含义：
- i：字符串以i下标结尾，及s[0...i]；
- dp[i]：s[0...i]中回文子串的数目。

递推公式：
当s[i] == s[0]
dp[i] = dp[i - 1] + 1
else dp[i] = dp[i - 1]

初始化：
每个字符本身都是一个回文子串，故应初始化为1。
*/

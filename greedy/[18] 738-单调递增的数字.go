package greedy

import "strconv"

// 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。
//
// 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。
//
// 示例 1:
//
// 输入: n = 10
// 输出: 9
//
// 示例 2:
//
// 输入: n = 1234
// 输出: 1234
//
// 示例 3:
//
// 输入: n = 332
// 输出: 299
//
// 提示:
//
// 0 <= n <= 10⁹
func monotoneIncreasingDigits(n int) int {
	ns := []byte(strconv.Itoa(n))
	idx := len(ns)
	for i := len(ns) - 1; i > 0; i-- {
		if ns[i-1] > ns[i] {
			ns[i-1]--
			idx = i
		}
	}
	for i := idx; i < len(ns); i++ {
		ns[i] = '9'
	}
	res, _ := strconv.Atoi(string(ns))
	return res
}

/**
思路：
以342为例，期望结果为339。
从后往前遍历，如果前一位 > 当前位，则先尝试将前一位减去1。
1. i = 2：4 > 2，故4 - 1，n = 332；
2. i = 1：3 <= 3，不处理；
3. i = 0，不满足i > 0的循环条件，跳出。
可以看出，此时332 < 342，但不是小于n的最大值。理想值应为349，即i=2及其后的数字都应全部改为9。

为什么要从后往前遍历？
前一位减1，后一位变9，更像是减法里面的借位处理，自然要从后往前。
如果是从前到后，会导致前面的可能调整好了，但是到后面又不满足要求了，又要倒推回去重新适配。

为什么idx要初始化为len(ns)？
对于1234这种场景，天然就是单调递增的，无需调整。
此时因为不满足 for i := idx; i < len(ns); i++ 的循环条件，不会将任何一位置为9。

为什么要在每轮循环中将前一位-1？
一开始的实现是记录最小的idx，整体比较结束后，只处理一次ns[idx-1]--。
但这样会导致1234这类无需处理的case，idx从始至终都是len(ns)，
此时执行ns[idx-1]--，会将结果变为1233，这是错误的。
所以一定要在每位比较时且前一位>当前位时去做借位-1。

而且延迟处理可能会漏掉新增的递减点。
*/

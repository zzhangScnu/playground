package greedy

import . "code.byted.org/zhanglihua.river/playground/tree"

// 给定一个二叉树，我们在树的节点上安装摄像头。
//
// 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
//
// 计算监控树的所有节点所需的最小摄像头数量。
//
// 示例 1：
//
// 输入：[0,0,null,0,0]
// 输出：1
// 解释：如图所示，一台摄像头足以监控所有节点。
//
// 示例 2：
//
// 输入：[0,0,null,0,null,0,null,null,0]
// 输出：2
// 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
//
// 提示：
//
// 给定树的节点数的范围是 [1, 1000]。
// 每个节点的值都是 0。

var count int

func minCameraCover(root *TreeNode) int {
	count = 0
	status := traverse(root)
	if status == 1 {
		count++
	}
	return count
}

func traverse(cur *TreeNode) int {
	if cur == nil {
		return 2
	}
	left, right := traverse(cur.Left), traverse(cur.Right)
	if left == 1 || right == 1 {
		count++
		return 0
	}
	if left == 0 || right == 0 {
		return 2
	}
	if left == 2 && right == 2 {
		return 1
	}
	return -1
}

/**
题意：对于一个摄像头来说，可以覆盖到上、中、下三层。
所以对一棵树来说，最优解是
父节点1
摄像头1
孩子节点1
父节点2
摄像头1
孩子节点2
即每隔2层放置一个摄像头，是数量最少且能覆盖所有节点的。


贪心思路：
自底向上遍历。
将节点状态分为三类：
0. 有摄像头；
1. 无摄像头且未覆盖：当前节点没有放置，且未被上层或下层的摄像头覆盖；
2. 无摄像头且已覆盖：当前节点没有放置，但被上层或下层的摄像头覆盖了；
需要使用后序遍历，当前节点需要根据孩子节点的状态来决定是否需要放置一个摄像头。
这里是单纯的状态传递，而不是动态规划的状态转移择优。


节点的处理分为几种情况：
1. 左右孩子任一放置了摄像头 -> 当前节点已被覆盖，无需额外放置摄像头 -> 需要向上返回2；
2. 左右孩子任一无摄像头且未覆盖 -> 当前节点需要放置摄像头 -> 需要向上返回0；
3. 左右孩子都无摄像头且已覆盖 -> 当前节点无需额外放置摄像头，但需要被上层节点覆盖 -> 需要向上返回1；


base case：
当遍历到的节点为nil时，返回什么值？
理想情况应该是：
叶子节点不放置摄像头，而是被其父节点覆盖。所以叶子节点应该向上返回1，
倒推nil节点应该向叶子节点返回2。
(映射到上面的图，
父节点1
摄像头1 -> 当前节点
孩子节点1 -> 叶子节点
父节点2 -> nil节点，被虚拟摄像头1覆盖
摄像头1
孩子节点2
)


为什么不是自顶向下遍历？
因为叶子节点的数量相较根节点，是指数级别的增长。
从下面开始放置摄影头，能用尽量少的摄像头覆盖尽可能多的节点。
局部最优：让叶子节点的父节点安摄像头，所需摄像头最少；
整体最优：全部摄像头数量所需最少。


特殊处理：
额外处理一下根节点，如果最终未被覆盖的话，还需要额外放置一个摄像头。
因为是自底向上的，所以根节点可能是未被覆盖的，需要额外处理一下。


处理顺序：
需要优先处理需要安装摄像头的分支条件。
否则会导致 [0,0,0,null,null,null,0] 这个case，
因根节点的右子树需要安装摄像头，right == 0，导致处理根节点时，先走到以下分支：
if left == 0 || right == 0 {
	return 2
}
从而导致根节点不装摄像头，根节点的左子树无法被正确覆盖，实际结果为1。
而期望结果为2，即根节点也需要装一个摄像头。
*/

package hashmap

// 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
//
// 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
//
// 示例 1：
//
// 输入：nums = [100,4,200,1,3,2]
// 输出：4
// 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
//
// 示例 2：
//
// 输入：nums = [0,3,7,2,5,8,4,6,0,1]
// 输出：9
//
// 示例 3：
//
// 输入：nums = [1,0,1,2]
// 输出：3
//
// 提示：
//
// 0 <= nums.length <= 10⁵
// -10⁹ <= nums[i] <= 10⁹
func longestConsecutiveII(nums []int) int {
	mapping := make(map[int]int)
	var res int
	for _, num := range nums {
		if _, exist := mapping[num]; exist {
			continue
		}
		left, right := mapping[num-1], mapping[num+1]
		curLen := left + right + 1
		res = max(res, curLen)
		mapping[num] = 1
		mapping[num-left] = curLen
		mapping[num+right] = curLen
	}
	return res
}

/**
核心思想：不记录每个数字的连续长度，而是只记录【连续区间的边界】及其对应的【区间总长度】，通过合并相邻区间来高效计算最长序列。
如区间[1, 4]，会产生两条记录：
- 左边界 1 对应的区间长度：1 -> 4。
- 右边界 4 对应的区间长度：4 -> 4。

一个数字是左边界还是右边界，不需要刻意提前判断，而是通过它【在连续区间中的位置】和【相邻数字的存在性】自然体现的。
对于任意连续区间 [a, b]（比如 [1,4]）：
左边界是 a（区间的起点）：它的左侧（a-1）不存在于哈希表中（否则区间可以向左扩展，a 就不是起点了）。
右边界是 b（区间的终点）：它的右侧（b+1）不存在于哈希表中（否则区间可以向右扩展，b 就不是终点了）。
区间内的中间数字（如 2、3）：两侧都有相邻数字（1 和 4 都存在），因此既不是左边界也不是右边界，不关注中间值。

不需要提前知道一个数字是左还是右边界，只需要利用边界的特性完成区间合并即可。
如果num - 1存在，说明num所在的区间可以向左扩展，区间起点会被更新；
如果num + 1存在，说明num所在的区间可以向右扩展，区间终点会被更新。

对比于原始版本的优化在于：
仅需要遍历一次原始数组，不需要多一次去重操作。
*/

package stack_queue

// 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
//
// 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
// 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
//
// 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
//
// 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
//
// 请你返回让 s 平衡的最少插入次数。
//
// 示例 1：
//
// 输入：s = "(()))"
// 输出：1
// 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))
// " 。
//
// 示例 2：
//
// 输入：s = "())"
// 输出：0
// 解释：字符串已经平衡了。
//
// 示例 3：
//
// 输入：s = "))())("
// 输出：3
// 解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
//
// 示例 4：
//
// 输入：s = "(((((("
// 输出：12
// 解释：添加 12 个 ')' 得到平衡字符串。
//
// 示例 5：
//
// 输入：s = ")))))))"
// 输出：5
// 解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
//
// 提示：
//
// 1 <= s.length <= 10^5
// s 只包含 '(' 和 ')' 。
func minInsertions(s string) int {
	var insertion, right int
	for _, ch := range s {
		if ch == '(' {
			right += 2
			if right%2 == 1 {
				insertion++
				right--
			}
		}
		if ch == ')' {
			if right > 0 {
				right--
			} else {
				insertion++
				right = 1
			}
		}
	}
	return insertion + right
}

/**
思路：
insertion、right分别为插入括号的数量、右括号的需求数量。
从左到右遍历字符串，以right为基准，通过对right的加减、判断来维护insertion，
最终结果即为insertion + right。

- 当遇到左括号时，需要补充2个右括号与其组成一对，故right += 2。
  如果此时right为奇数，则需要额外的一个右括号，与已有的一个右括号一起，跟当前左括号组成合法对。此时：
	- insertion++，需要插入一个右括号；
	- right--，新插入一个右括号，故对右括号的需求减少；
- 当遇到右括号时，
	- 如果此时right > 0，则该新增右括号可以抵消一个右括号需求，即right--；
	- 否则，即right == 0，则当前对右括号暂无需求，当前遇到的右括号是多出来的。此时：
		- insertion++，需要插入一个左括号，来跟当前的右括号组成一对（此时还缺一个右括号）；
		- right = 1，因为还缺一个右括号，所以令right = 1。

注意，左右括号的处理是有先后顺序要求的。
先遇到左括号，可以增加右括号需求数量，在遇到右括号时进行抵消；
但反之不行，即不可以在遇到右括号时，增加左括号需求，在后续遇到左括号时再抵消。因为合法对一定是先左括号、再右括号组成的。
*/

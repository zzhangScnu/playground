- 特性：单调队列结合了普通队列 + 单调性，通过自定义规则维护队列中的元素，使其单调递增/递减有序。
- 解决问题：滑动窗口
    - 例如，在O(1)时间复杂度寻找滑动窗口中的最大值。
        - 若仅考虑在集合中添加元素，可以通过比较当前维护的最大元素和加入元素，O(1)地动态计算最大元素；
        - 若滑动窗口场景：
            - 在集合中添加元素的同时删除元素，不依赖其他数据结构的情况下需要重新扫描集合中的元素，O(n)地动态计算最大元素；
            - 此时可以引入单调队列，在队列中维护滑动窗口内元素为单调递减，即队口是最大值。这样就可以在滑动窗口移动时，O(1)
              地动态计算最大元素。
- 可以通过双端队列deque实现：
    ```
    type MonotonicQueue struct {
        data []int
    }
    ```
    - 在队尾插入元素：循环判断，如果前面的元素比插入元素小，则出队。可以理解为量级较小的元素都被压扁了，直到遇到量级更大的才停止。
    ```
    func (q *MonotonicQueue) Push(n int) {
        for len(q.data) > 0 && q.data[len(q.data)-1] < n {
            q.data = q.data[:len(q.data)-1] // 移除尾部元素
        }
        q.data = append(q.data, n)
    }
    ```
    - 返回最大值：如果每个元素都遵循此规则，最终队列中的元素大小会保持单调递减顺序。因此队头元素即为最大值。
    ```
    func (q *MonotonicQueue) Max() int {
        return q.data[0]
    }
    ```
    - 在队头删除元素：之所以要判断队头元素是否与待删除元素一致，是因为该元素可能在新元素入队时就已经出队。
    ```
    func (q *MonotonicQueue) Pop(n int) {
        if len(q.data) > 0 && q.data[0] == n {
            q.data = q.data[1:] // 移除头部元素
        }
    }
    ```
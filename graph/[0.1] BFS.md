# 核心

- 由层序遍历演化而来；
- 在图中呈环形方式遍历；
- 由于“齐头并进”特性，在寻找到目标节点时也找到一条最短路径。

# 演进思想
// 输⼊⼀棵⼆叉树的根节点，层序遍历这棵⼆叉树
void levelTraverse(TreeNode root) {
if (root == null) return 0;
Queue<TreeNode> q = new LinkedList<>();
q.offer(root);
int depth = 1;
// 从上到下遍历⼆叉树的每⼀层
while (!q.isEmpty()) {
int sz = q.size();
// 从左到右遍历每⼀层的每个节点
for (int i = 0; i < sz; i++) {
TreeNode cur = q.poll();
printf("节点 %s 在第 %s 层", cur, depth);
// 将下⼀层节点放⼊队列
if (cur.left != null) {
q.offer(cur.left);
}
if (cur.right != null) {
在线⽹站 labuladong的刷题三件套
372 / 707
q.offer(cur.right);
}
}
depth++;
}
}
while 循环控制⼀层⼀层往下⾛，for 循环利⽤ sz 变量控制从左到右遍历每⼀层⼆叉树节点。


基于⼆叉树的遍历框架，我们⼜可以扩展出多叉树的层序遍历框架：
// 输⼊⼀棵多叉树的根节点，层序遍历这棵多叉树
void levelTraverse(TreeNode root) {
if (root == null) return;
Queue<TreeNode> q = new LinkedList<>();
q.offer(root);
int depth = 1;
// 从上到下遍历多叉树的每⼀层
while (!q.isEmpty()) {
int sz = q.size();
// 从左到右遍历每⼀层的每个节点
for (int i = 0; i < sz; i++) {
在线⽹站 labuladong的刷题三件套
373 / 707
TreeNode cur = q.poll();
printf("节点 %s 在第 %s 层", cur, depth);
// 将下⼀层节点放⼊队列
for (TreeNode child : cur.children) {
q.offer(child);
}
}
depth++;
}
}
基于多叉树的遍历框架，我们⼜可以扩展出 BFS（⼴度优先搜索）的算法框架：
// 输⼊起点，进⾏ BFS 搜索
int BFS(Node start) {
Queue<Node> q; // 核⼼数据结构
Set<Node> visited; // 避免⾛回头路

q.offer(start); // 将起点加⼊队列
visited.add(start);
int step = 0; // 记录搜索的步数
while (q not empty) {
int sz = q.size();
/* 将当前队列中的所有节点向四周扩散⼀步 */
for (int i = 0; i < sz; i++) {
Node cur = q.poll();
printf("从 %s 到 %s 的最短距离是 %s", start, cur, step);
/* 将 cur 的相邻节点加⼊队列 */
for (Node x : cur.adj()) {
if (x not in visited) {
q.offer(x);
visited.add(x);
}
}
}
step++;
}
}


# 实现

- 用队列管理待遍历节点；
- 在无向图中用visited维护已访问节点，避免重复访问导致无限循环；
- 在二叉树等有向无环图中，由于只能单向遍历，所以天然不存在重复访问场景；
- 在二叉树遍历过程中，【for queue 不为空】控制纵向遍历，【for queue 中当前元素个数】控制横向遍历。

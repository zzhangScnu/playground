# 基本框架

## 动态规划框架

```
for 状态1 IN 状态1的所有取值
    for 状态2 IN 状态2的所有取值
        ...
            dp[状态1][状态2][...] = 择优(选择1, 选择2)
```

## 本题前提条件

- i：第i天，[0, len(prices))
- prices：每一天的股票价格
- k：最大交易次数限制，[1, K]

## 本题核心分析

### 状态分析

- 状态1：当前是第几天
- 状态2：最大交易次数限制：不是已交易次数，而是当前允许交易次数的最大限制。
- 状态3：当天的操作：买入、卖出、无操作。<br>
  但因为卖出须在买入后、买入须在卖出后，存在先后时序限制，所以不操作也分为买入后的不操作和卖出后的不操作。<br>
  只有细化了选择，才好在递推公式中表达业务语义。
  故操作选择可以细化为：
    - 持有
        - 买入
        - 不操作
    - 未持有
        - 卖出
        - 不操作

### 递推公式

#### 概念

dp[i][k][j]：表示在第i天，持有股票状态为j时(持有为1、未持有为0)，且最大交易次数限制为k时的最大利润。

- 0 <= i < n
- 1 <= k <= K
- j IN (0, 1)<br>

穷举共n * K * 2种状态。
则题解为dp[n-1][K][0]，即最后一天，最多允许K次交易时，不持有股票的最大利润。(因为卖出的利润一定大于持有)

#### 整体框架

```
for i IN [0, n)
    for k IN [1, K]
        for j IN [0, 1]
            dp[i][k][j] = max(不操作, 买入 / 卖出)
```

#### 状态转移

##### 分析

第i天，最大交易次数限制为k时，当前持有状态j有两种情况：

- 持有：可由以下两种情况转移而来：
    - 前一天持有：第i-1天，持有状态为持有1，因未发生交易，交易次数上限不变仍为k；<br>
    - 前一天未持有：第i-1天，持有状态为未持有0，因发生买入交易，交易次数上限为k-1。<br>
      因为交易总是从买入开始，所以应在买入时扣减交易次数上限。否则如果在卖出时才扣减，可能会超出交易次数限制。<br>
      此时应在第i-1天的利润上扣减买入成本；<br>
- 未持有：可由以下两种情况转移而来：
    - 前一天未持有：第i-1天，持有状态为未持有0，因未发生交易，交易次数上限不变仍为k；<br>
    - 前一天持有：第i-1天，持有状态为持有1，发生卖出入交易，但因为一对买入&卖出为一次交易，在买入时已经扣减次数，故在卖出时交易次数上限不变仍为k。<br>
      此时应在第i-1天的利润上加入卖出收入。<br>

##### 结论

```
dp[i][k][1] = max(dp[i-1]][k][1], dp[i-1]][k-1][0]-prices[i])
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
```

### base case

由递推公式可知，i依赖于i-1推导而来，k依赖于k-1推导而来，i和k可能会产生数组越界情况。<br>
因为i从0开始，k从1开始，<br>
所以需要初始化i == -1 || k == 0的dp值。<br>

- 若i == -1：此时买卖周期还未开始
    - j == 0：不持有的最大利润初始化为0；
    - j == 1：持有的场景理论上不存在，但因为要在递推公式中取最大值，故初始化为最小值；
- 若k == 0：此时最大交易次数限制为0，即不允许交易
    - j == 0：不持有的最大利润初始化为0；
    - j == 1：持有的场景理论上不存在，但因为要在递推公式中取最大值，故初始化为最小值。

### 案例分析

#### 仅可买卖一次

即k == 1。将k == 1代入递推公式并简化。

```
dp[i][1][1] = max(dp[i-1]][1][1], dp[i-1]][0][0]-prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1]+prices[i])
```

由base case可知，k == 0 && j == 0时，dp = 0，所以可简化为：

```
dp[i][1][1] = max(dp[i-1]][1][1], -prices[i]) // 略去了dp[i-1]][0][0]
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1]+prices[i])
```

因为固定k值，即不会发生转移，所以可以不将k作为状态在递推公式中体现：

```
dp[i][1] = max(dp[i-1][1], -prices[i])
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
```

base case：i == 0时，dp[i-1][*]会发生数组越界，故初始化：

```
dp[0][1] = max(dp[-1][1], -prices[0])
         = max(最小值, -prices[0]) // 由上述base case分析可知，i == -1 && j == 1时，dp为最小值
         = -prices[0]

dp[0][0] = max(dp[-1][0], dp[-1][1]+prices[0])
         = max(0, 最小值+prices[0]) // 由上述base case分析可知，i == -1 && j == 0时，dp为0；同理dp[-1][1]为最小值
         = 0
```

可以看出i只跟i - 1有关，故可以将二维DP压缩成一维。

#### 可买卖无数次

题目中给出的可以在同一天买入卖出，其实无需考虑，因为这样利润为零，等同于没有交易。<br>
k == 无限，则可以认为k和k - 1是一样的，不存在限制能力。将k == k - 1等式代入递推公式：<br>

```
dp[i][k][1] = max(dp[i-1]][k][1], dp[i-1]][k][0]-prices[i])
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
```

可以看出k不会发生改变，所以直接省略可得：

```
dp[i][1] = max(dp[i-1]][1], dp[i-1]][0]-prices[i])
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
```

base case：

```
dp[0][1] = max(dp[-1]][1], dp[-1]][0]-prices[0])
         = max(最小值, -prices[0])
         = -prices[0]

dp[0][0] = max(dp[-1][0], dp[-1][1]+prices[0])
         = max(0, 最小值+prices[0])
         = 0
```

#### 可买卖无数次&含冷冻期

k == 无限，买入时需要在卖出冷静一天后才能进行。<br>
在上一题的基础上，修改买入时i的转移方式，从i - 1转移到i，改为i - 2转移到i。即：<br>

```
dp[i][1] = max(dp[i-1]][1], dp[i-2]][0]-prices[i]) // dp[i-2][0]-prices[i]中由i-2转移到i
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
```

base case需考虑i - 2的情况。

#### 含手续费

k == 无限，交易时含手续费。则在买入/卖出时加入手续费的计算：

```
dp[i][1] = max(dp[i-1]][1], dp[i-1]][0]-prices[i])
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)
```

base case需考虑加入手续费的计算。

#### 可以买卖两次

k == 2，即有了k的限制，此时不能再省略k了，递推公式为：

```
dp[i][k][1] = max(dp[i-1]][k][1], dp[i-1]][k-1][0]-prices[i])
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
```

且需要增加一个for循环遍历k从而枚举所有情况，或者直接将k == 1和k == 2的情况平铺出来：

```
dp[i][1][1] = max(dp[i-1]][1][1], dp[i-1]][0][0]-prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1]+prices[i])
dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0]-prices[i])
dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1]+prices[i])
```

base case：
i == 0时，

```
dp[0][1][1] = max(dp[-1]][1][1], dp[-1][0][0]-prices[0]) = -prices[0]
dp[0][1][0] = max(dp[-1][1][0], dp[-1][1][1]+prices[0]) = 0
dp[0][2][1] = max(dp[-1]][2][1], dp[-1]][1][0]-prices[0]) = -prices[0]
dp[0][2][0] = max(dp[-1][2][0], dp[-1][2][1]+prices[0]) = 0
```

#### 可以买卖k次

```
for i IN [0, n)
    for k IN [K, 1]
        dp[i][k][1] = max(dp[i-1]][k][1], dp[i-1]][k-1][0]-prices[i])
        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])
```

因为最大交易次数限制是随着交易的进行逐渐减少的，所以对k的遍历从K开始逐渐递减会更符合业务语义。<br>
且因为dp[i][k][1]依赖的dp[i-1]][k-1][0]，在上一行的计算中已经得出结果，所以无论正向还是反向遍历k，都是符合预期的。<br>
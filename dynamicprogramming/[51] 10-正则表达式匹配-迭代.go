package dynamicprogramming

// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
//
// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素
//
// 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。
//
// 示例 1：
//
// 输入：s = "aa", p = "a"
// 输出：false
// 解释："a" 无法匹配 "aa" 整个字符串。
//
// 示例 2:
//
// 输入：s = "aa", p = "a*"
// 输出：true
// 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
//
// 示例 3：
//
// 输入：s = "ab", p = ".*"
// 输出：true
// 解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
//
// 提示：
//
// 1 <= s.length <= 20
// 1 <= p.length <= 20
// s 只包含从 a-z 的小写字母。
// p 只包含从 a-z 的小写字母，以及字符 . 和 *。
// 保证每次出现字符 * 时，前面都匹配到有效的字符
func isMatch(s string, p string) bool {
	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]bool, n+1)
	}
	dp[0][0] = true
	for j := 1; j <= n; j++ {
		if p[j-1] == '*' {
			dp[0][j] = dp[0][j-2]
		}
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' {
				dp[i][j] = dp[i][j-2]
				if s[i-1] == p[j-2] || p[j-2] == '.' {
					dp[i][j] = dp[i][j] || dp[i-1][j]
				}
			}
		}
	}
	return dp[m][n]
}

/**
DP数组及下标含义：
- i：字符串s中的下标，即以s[i]为结尾；
- j：正则表达式p中的下标，即以p[j]为结尾；
- dp[i][j]：以s[i]为结尾的字符串，是否能被p[j]为结尾的正则表达式匹配。


递推公式：
for i IN (1, len(s))
	for j IN (1, len(p))

		case1：s和p当前位置均为普通字符串
		if s[i] == p[j]
			dp[i][j] = dp[i-1][j-1]

		case2：p当前位置为.
		if p[j] == '.'
			dp[i][j] = dp[i-1][j-1]

		case3：p当前位置为*
		if p[j] == '*'
			dp[i][j] = dp[i][j-2]
			if p[j-2] == '.' || s[i-1] == p[j-2] // 匹配
				dp[i][j] =  dp[i][j] || dp[i-1][j]

注意，因为题目中明确限定s的长度>=1，即不存在空字符串的场景，所以这种实现已经满足诉求。
但如果s == ""，则需要额外处理一种场景，即 p == "a*b*c*"的情况。


初始化：
因为i&j依赖于i-1、j-1、j-2推导而来，所以需要考虑数组越界情况。
所以dp初始化为(m + 1) * (n + 1)大小，保持默认零值即可。


遍历方向：
因为i&j依赖于i-1、j-1、j-2推导而来，所有从左往右、由上到下即可。
*/

//	for i := 0; i <= m; i++ {
//		dp[i][0] = false
//	}

// 这种方法通过调整循环顺序（先遍历模式 p，再遍历字符串 s）避免单独初始化的核心在于：确保每个状态转移所需的前置状态都已被正确计算。让我详细解释这个过程：
//动态规划中的状态依赖关系
//在正则表达式匹配中，dp[i][j] 表示字符串 s 的前 i 个字符和模式 p 的前 j 个字符是否匹配。状态转移主要涉及两种情况：
//普通字符或 .：dp[i][j] 依赖于 dp[i-1][j-1]。
//* 通配符：dp[i][j] 依赖于 dp[i][j-2]（忽略 *）和 dp[i-1][j]（重复前一个字符）。
//关键观察：
//当处理 * 时，需要确保 dp[i][j-2] 和 dp[i-1][j] 已经被计算。
//当处理普通字符或 . 时，需要确保 dp[i-1][j-1] 已经被计算。
//原代码的问题
//原代码的循环顺序是：
//go
//for i := 1; i <= m; i++ {
//    for j := 1; j <= n; j++ {
//        // ...
//    }
//}
//这种顺序下，当 j 遇到 * 时，dp[0][j-2] 可能未被初始化（例如 p 以 a* 开头），导致状态转移错误。
//调整循环顺序后的逻辑
//新的循环顺序是：
//go
//for j := 1; j <= n; j++ {
//    for i := 0; i <= m; i++ {
//        // ...
//    }
//}
//这样做的好处是：
//按模式 p 的每个字符依次处理：
//对于每个 j（模式 p 的前 j 个字符），遍历所有可能的 i（字符串 s 的前 i 个字符）。
//当处理 * 时，由于 j 是递增的，j-2 对应的所有状态（即 dp[0..m][j-2]）已经在之前的迭代中计算完成。
//正确处理空字符串匹配：
//当 i=0 时，dp[0][j] 会在遍历 j 的过程中被正确计算。例如：
//若 p[j-1] == '*'，则 dp[0][j] = dp[0][j-2]（继承忽略 * 的结果）。
//这个逻辑隐式替代了原代码中的初始化步骤。
//处理 * 的状态转移：
//当 p[j-1] == '*' 时，dp[i][j] 依赖于 dp[i][j-2] 和 dp[i-1][j]。
//由于 i 是递增的，dp[i-1][j] 已经在当前 j 的迭代中被计算（i-1 先于 i 被处理）。
//示例验证
//以输入 s="aa" 和 p="a*" 为例：
//初始化：dp[0][0] = true。
//遍历 j=1（p[0]='a'）：
//i=0：dp[0][1] = false（空字符串无法匹配 a）。
//i=1：dp[1][1] = true（s[0]='a' 匹配 p[0]='a'）。
//i=2：dp[2][1] = false（s 的前两个字符 "aa" 无法匹配 a）。
//遍历 j=2（p[1]='*'）：
//i=0：dp[0][2] = dp[0][0] = true（"a*" 可以匹配空字符串）。
//i=1：dp[1][2] = dp[1][0] || dp[0][2] = false || true = true（"a" 可以被 "a*" 匹配）。
//i=2：dp[2][2] = dp[2][0] || dp[1][2] = false || true = true（"aa" 可以被 "a*" 匹配）。
//总结
//通过先遍历模式 p，再遍历字符串 s，确保了：
//处理 * 时，dp[i][j-2] 和 dp[i-1][j] 已被计算。
//空字符串匹配（i=0）的情况会在遍历 j 的过程中被正确初始化。
//所有状态依赖关系都按顺序被满足，无需额外的初始化步骤。
//这种方法本质上是将初始化逻辑融入了状态转移的主循环中，通过调整计算顺序来保证正确性。

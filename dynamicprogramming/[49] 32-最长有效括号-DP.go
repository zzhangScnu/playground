package dynamicprogramming

// 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
//
// 示例 1：
//
// 输入：s = "(()"
// 输出：2
// 解释：最长有效括号子串是 "()"
//
// 示例 2：
//
// 输入：s = ")()())"
// 输出：4
// 解释：最长有效括号子串是 "()()"
//
// 示例 3：
//
// 输入：s = ""
// 输出：0
//
// 提示：
//
// 0 <= s.length <= 3 * 10⁴
// s[i] 为 '(' 或 ')'
func longestValidParentheses(s string) int {
	var longest int
	n := len(s)
	dp := make([]int, n)
	for i := 1; i < n; i++ {
		if s[i] == '(' {
			continue
		}
		if s[i-1] == '(' {
			dp[i] = 2
			if i >= 2 {
				dp[i] += dp[i-2]
			}
		} else if s[i-1] == ')' && i >= dp[i-1]+1 && s[i-dp[i-1]-1] == '(' {
			dp[i] = dp[i-1] + 2
			if i >= dp[i-1]+2 {
				dp[i] += dp[i-dp[i-1]-2]
			}
		}
		longest = max(longest, dp[i])
	}
	return longest
}

/**
最开始的做法，是参照最长回文子序列的DP做法。
即用一个二维数组dp[i][j]，记录s[i, j]索引区间内的有效括号最大长度。
核心逻辑：
for i := 0; i < len(s); i++
	for j := i + 1; j < len(s); j++
		- 若s[i] == '(' && s[j] == ')'，即为合法括号对，则在掐头去尾的子字符串s[i + 1, j]的有效括号最大长度dp[i + 1][j - 1]基础上+2；
			- 若此时i + 1 == j，即i和j相邻，则令dp[i][j] = 2。
		- 否则，取包含i或包含j的子字符串的较大者，即max(dp[i][j - 1], dp[i + 1][j])。
存在的问题是：
回文子序列不要求连续，即字符串中间允许出现其他字符。但合法的括号对需要强制连续，但递推公式会将字符串割裂，如()(())，
dp[0][5] = max(dp[1][5], dp[0][4]) → 拆分两个独立区间，但实际上整个字符串是连续的6位有效括号。

正确思路：
用一维数组dp[i]，记录以s[0, i]索引区间内的有效括号最大长度。
- 当前位置i为左括号时：令dp[i] = 0。因为合法括号串一定是以右括号结尾的，故不处理；
- 当前位置i为右括号时：
	- 如果前一个位置i - 1为左括号，可以组成 ...()：
	  最大长度 = 前面 ... 的最大长度 + 2 = dp[i - 2] + 2。注意可能出现的越界情况：
		- ...() 实际是 )，不处理，长度 = 0；
		- ...() 实际是 ()，长度 = 2；
	- 如果前一个位置i - 1为右括号，即 ...))，则看i - 1的右括号是否能和更前面的位置组成合法括号串：
	  已知dp数组存储的是以i下标作为结尾的字符串区间中的最长合法括号串，且合法括号串要求连续，所以dp[i - 1]代表的是以i - 1对应的右括号为结尾的合法括号串的长度。
	  那么该长度再往前一个位置h，即 s[i-dp[i-1]-1] ，如果是左括号，就能与i对应的右括号组成一对。此时dp[i] = dp[i - 1] + 2。
	  此外，还应算上h更前面的合法括号串长度dp[i-dp[i-1]-2]。
	  同样，需要注意可能的越界情况。即对数组的索引，下标位置需要 >= 0。
*/

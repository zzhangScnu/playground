package dynamicprogramming

// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
//
// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
//
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
//
// 示例 1:
//
// 输入：prices = [3,3,5,0,0,3,1,4]
// 输出：6
// 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
//
// 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
//
// 示例 2：
//
// 输入：prices = [1,2,3,4,5]
// 输出：4
// 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
//
//	注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
//	因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
//
// 示例 3：
//
// 输入：prices = [7,6,4,3,1]
// 输出：0
// 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
//
// 示例 4：
//
// 输入：prices = [1]
// 输出：0
//
// 提示：
//
// 1 <= prices.length <= 10⁵
// 0 <= prices[i] <= 10⁵
func maxProfitIII(prices []int) int {
	n := len(prices)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, 4)
	}
	dp[0][0], dp[0][1], dp[0][2], dp[0][3] = -prices[0], 0, -prices[0], 0
	for i := 1; i < n; i++ {
		dp[i][0] = max(dp[i-1][0], -prices[i])
		dp[i][1] = max(dp[i-1][1], dp[i][0]+prices[i])
		dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])
		dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])
	}
	return dp[n-1][3]
}

/**
DP数组及下标含义：
因为状态较多，将所有状态都展开表示：
- i：第i天；
- dp[i][0]：第i天第一次持有的最大利润；
- dp[i][1]：第i天第一次不持有的最大利润；
- dp[i][2]：第i天第二次持有的最大利润；
- dp[i][3]：第i天第二次不持有的最大利润。
交易顺序需严格遵守：【第一次买入 → 第一次卖出 → 第二次买入 → 第二次卖出】的完整流程，符合要求的两笔交易限制。
这点体现在递推公式的设计上。

递推公式：
要么是延续前一天的持有/不持有状态，要么是基于前一天的持有/不持有状态来操作买入/卖出。
dp[i][0] = max(dp[i-1][0], -prices[i])：第一次买入基于初始本金0，而不是先前的利润。
dp[i][1] = max(dp[i-1][1], dp[i][0]+prices[i])
dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])
dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])
res = max(dp[len(prices)-1][0], dp[len(prices)-1][2])
其实直接返回dp[len(prices)-1][2]作为结果即可，因为第二次买入+卖出是基于第一次的，所以第二次的利润会包含第一次。
假如第一次的利润已经最大，那么可以将第二次买卖理解为在第一次利润最大时的当天进行，那么还是最大值还是第一次的利润。

初始化：
可以看出，dp[i]的推导依赖于dp[i-1]。故初始化dp[0]。
dp[0][0] = -prices[0]
dp[0][1] = 0
dp[0][2] = -prices[0]
dp[0][3] = 0

遍历方向：
从左到右。
*/

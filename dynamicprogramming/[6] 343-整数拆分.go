package dynamicprogramming

// 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
//
// 返回 你可以获得的最大乘积 。
//
// 示例 1:
//
// 输入: n = 2
// 输出: 1
// 解释: 2 = 1 + 1, 1 × 1 = 1。
//
// 示例 2:
//
// 输入: n = 10
// 输出: 36
// 解释: 10 = 3 + 3 + 4, 3 ×3 ×4 = 36。
//
// 提示:
//
// 2 <= n <= 58
func integerBreak(n int) int {
	dp := make([]int, n+1)
	dp[1], dp[2] = 0, 1
	for i := 3; i <= n; i++ {
		for j := 1; j <= i/2; j++ {
			dp[i] = max(dp[i], j*(i-j), j*dp[i-j])
		}
	}
	return dp[n]
}

/**
DP数组及含义：
- i：小于等于n的正整数，即 0 <= i <= n
- dp[i]：正整数i可拆分整数的最大乘积

递推公式：
自己写出来的是这样：dp[i] = max(dp[i - 1] * 1, dp[i - 2] * 2, ..., dp[0] * i)
默认了拆分成【>= 3个正整数】来求相乘结果。
由题可得拆分为k个正整数的和(k >= 2)，应该将拆分成2个正整数的情况也考虑进去：
dp[i] = max(
	max(1 * (i - 1), 1 * dp[i - 1]),
	max(2 * (i - 2), 2 * dp[i - 2]),
	...)
抽象一下，就是 j range [1 -> i-1]，
dp[i] = max(j * (i - j), j * dp[i - j]))
其中，
j * (i - j)：将i拆分成j和(i - j)两个正整数并相乘；
j * dp[i - j])：从i中先把j拆出来，再把剩余部分做进一步拆分，dp[i - j]表示该剩余部分拆分后可得出的最大乘积；
两者取大。

这里有个问题：为什么在j * dp[i - j])中，只拆分后半部分，而不拆分j了？
举例：i = 6，j和(i - j)的拆分情况枚举如下：
1 * 5
2 * 4
3 * 3
4 * 2
5 * 1
对1 * 5中的5做拆分，则会有一种结果是1 * 1 * 1 * 1 * 1，
对2 * 4来说，如果拆分2，就会有1 * 1 * 4，如果4再拆分，也会得到1 * 1 * 1 * 1 * 1，已经被覆盖过了。
因为j是从1开始遍历，拆分j的情况，在遍历j的过程中已经计算过了。

优化方案：j实际上仅需range [1 -> i/2]
若拆分成k个数乘积最大，要求这k个数分布比较均匀、大小比较接近。
如果j超过i/2，再对剩余部分进行拆分，相乘的结果一定不是最大。

初始化：dp[1] = 0, dp[2] = 1
遍历顺序：从前到后
*/

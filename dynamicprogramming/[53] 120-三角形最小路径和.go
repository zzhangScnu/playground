package dynamicprogramming

// 给定一个三角形 triangle ，找出自顶向下的最小路径和。
//
// 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果
// 正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
//
// 示例 1：
//
// 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
// 输出：11
// 解释：如下面简图所示：
//
//	 2
//	3 4
//
// 6 5 7
// 4 1 8 3
// 自顶向下的最小路径和为11（即，2+3+5+1= 11）。
//
// 示例 2：
//
// 输入：triangle = [[-10]]
// 输出：-10
//
// 提示：
//
// 1 <= triangle.length <= 200
// triangle[0].length == 1
// triangle[i].length == triangle[i - 1].length + 1
// -10⁴ <= triangle[i][j] <= 10⁴
//
// 进阶：
//
// 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？
func minimumTotal(triangle [][]int) int {
	length := len(triangle[len(triangle)-1]) + 1
	dp := make([]int, length)
	for i := len(triangle) - 1; i >= 0; i-- {
		for j := 0; j <= i; j++ {
			dp[j] = triangle[i][j] + min(dp[j], dp[j+1])
		}
	}
	return dp[0]
}

/**
思路：
从下到上遍历。
主要原因：
1. 仅使用O(三角形的行数)的空间复杂度；
2. 规避从上到下可能带来的数组越界问题。由下往上的话由于是倒三角，下比上宽，推导第i-1行第j列时，能确保第i行的第j列和第j+1列一定存在；
3. 可以将节点+路径选择抽象为决策树。基于该树：
   - 如果从上到下，需要遍历每一个节点的可能路径。使用递归的处理方式，触底回溯后才能推算出最短路径。即使引入备忘录机制，也需三角形中节点数量的额外堆栈空间；
   - 如果从下到上，可以通过第i-1层已计算出来的两种选择推导出第i层的最佳选择，且每层仅依赖前一层的计算结果，仅需额外的三角形行数大小的空间。


DP数组及下标含义
由模拟过程可知，从下向上推导时，每层仅依赖前一层的计算结果，故使用一维DP即可。
- j：每一行的第i个位置
- dp[j]：从第0行走到每一行的第i个位置时的最短路径长度

递推公式
for i range (len(triangle)-1, 0) //
	for j range (0, len(triangle)) // 由三角形特性可知，列大小 == 行数 + 1
		dp[j] = triangle[i][j] + min(dp[j], dp[j+1])
结果存储在dp[0]中


遍历方向
行从下往上
列从左往右


初始化
创建一个跟三角形底边大小相当的一维DP数组，保持默认初始值。
即叶子节点的下一层节点的权重均为0。



跟矩形最短路径题目的区别：
1. 最短路径：
三角形：最短路径不固定，终点可能落在末行的任意一个位置。所以如果从上到下推导，最终需要遍历末行的每一个位置，找到最短路径；
矩形：固定从左上角 -> 右下角；
2. 每行长度：
三角形：每行不同；
矩形：每行相同；
但每行都从上一行下降而来，也都存在数组越界的可能，如当前位置在每行的最左或最右。
但矩形题是用DP数组的额外空间+特殊初始化来规避，而三角形题是通过由下到上反向推导来规避。
*/

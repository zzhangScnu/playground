package dynamicprogramming

// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
//
// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素
//
// 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。
//
// 示例 1：
//
// 输入：s = "aa", p = "a"
// 输出：false
// 解释："a" 无法匹配 "aa" 整个字符串。
//
// 示例 2:
//
// 输入：s = "aa", p = "a*"
// 输出：true
// 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
//
// 示例 3：
//
// 输入：s = "ab", p = ".*"
// 输出：true
// 解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
//
// 提示：
//
// 1 <= s.length <= 20
// 1 <= p.length <= 20
// s 只包含从 a-z 的小写字母。
// p 只包含从 a-z 的小写字母，以及字符 . 和 *。
// 保证每次出现字符 * 时，前面都匹配到有效的字符
func isMatch(s string, p string) bool {
	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]bool, n+1)
	}
	dp[0][0] = true
	for j := 1; j <= n; j++ {
		if p[j-1] == '*' {
			dp[0][j] = dp[0][j-2]
		}
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' {
				dp[i][j] = dp[i][j-2]
				if s[i-1] == p[j-2] || p[j-2] == '.' {
					dp[i][j] = dp[i][j] || dp[i-1][j]
				}
			}
		}
	}
	return dp[m][n]
}

/**
正则表达式：
. ： 匹配一个任意字符，如 a 和 .
X* ： X是一个字符，*是一个量词，可以表示0次、1次、N次
	匹配0个字符，即出现0次：如 "" 和 b*
	匹配多个X字符，即出现多次：如 bbb 和 b*


DP数组及下标含义：
- i：字符串s中的下标，即以s[i]为结尾；
- j：正则表达式p中的下标，即以p[j]为结尾；
- dp[i][j]：以s[i]为结尾的字符串，是否能被p[j]为结尾的正则表达式匹配。


递推公式：
for i IN (1, len(s))
	for j IN (1, len(p))

		case1：s和p当前位置均为普通字符串，则需相等才可匹配
		if s[i] == p[j]
			dp[i][j] = dp[i-1][j-1]

		case2：p当前位置为.，则s当前位置任意字符均可匹配
		if p[j] == '.'
			dp[i][j] = dp[i-1][j-1]

		case3：p当前位置为*，则：
			- 匹配0次：s当前位置需要是""，但因为空字符串不占用索引位置，所以s的没有任何字符被消耗；
					  而p中 X* 即p[i-1]和p[i] 这两个字符被忽略，有效部分从p[0..j-1]缩减为p[0..j-3]。
					  如s == aa，i == 1和p == ab*，j == 2，此时s[1] == a，p[2] == *，a和b*匹配0次的情况下，等价于s == aa 和 p == a，即依赖于dp[i][j-2]的匹配结果。
			- 匹配1次或多次：. 或 p中*前面的字符
		if p[j] == '*'
			dp[i][j] = dp[i][j-2] // 匹配0次
			if p[j-2] == '.' || s[i-1] == p[j-2] // 匹配1次(如果是多次如N次的话，本次消耗s的一个字符，即i基于i-1转移而来。剩下的N-1次交给dp[i+1][j]处理)
				dp[i][j] =  dp[i][j] || dp[i-1][j]


注意，因为题目中明确限定s的长度>=1，即不存在空字符串的场景，所以这种实现已经满足诉求。
但如果s == ""，则需要额外处理一种场景，即 p == "a*b*c*"的情况。


初始化：
因为i&j依赖于i-1、j-1、j-2推导而来，所以需要考虑数组越界情况。
所以dp初始化为(m + 1) * (n + 1)大小，避免数组越界且方便计算，保持默认零值即可。
所以dp[i][j]表示s[0, i - 1]，p[0, j - 1]的匹配情况。

但存在一种特殊情况：p == X*时，可以匹配s == ""。
即i == 0时，若p[j] == '*'，则dp值为true。如果不初始化i == 0时的这种情况，会导致后续推演错误。
所以初始化逻辑为：
dp[0][0] = true // 空字符串和空模式相匹配
for j := 1; j <= n; j++ {
	if p[j-1] == '*' { // 若p当前位为*
		dp[0][j] = dp[0][j-2] // 与空字符串的匹配结果实际为true
	}
}

遍历方向：
因为i&j依赖于i-1、j-1、j-2推导而来，所有从左往右、由上到下即可。
*/

/*
*
这种做法更好，i&j从0开始遍历且增加越界判断，
会将i == 0的情况囊括且正确赋值。
*/
func isMatchBetter(s string, p string) bool {
	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]bool, n+1)
	}
	dp[0][0] = true
	for i := 0; i <= m; i++ {
		for j := 0; j <= n; j++ {
			if i > 0 && j > 0 && (s[i-1] == p[j-1] || p[j-1] == '.') {
				dp[i][j] = dp[i-1][j-1]
			} else if j > 0 && p[j-1] == '*' {
				dp[i][j] = dp[i][j-2]
				if i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') {
					dp[i][j] = dp[i][j] || dp[i-1][j]
				}
			}
		}
	}
	return dp[m][n]
}

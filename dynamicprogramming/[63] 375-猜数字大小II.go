package dynamicprogramming

import "math"

// 我们正在玩一个猜数游戏，游戏规则如下：
//
// 我从 1 到 n 之间选择一个数字。
// 你来猜我选了哪个数字。
// 如果你猜到正确的数字，就会 赢得游戏 。
// 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
// 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
//
// 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。
//
// 示例 1：
//
// 输入：n = 10
// 输出：16
// 解释：制胜策略如下：
// - 数字范围是 [1,10] 。你先猜测数字为 7 。
//   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
//   - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
//   - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
//   - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
//   - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
//   - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
//   - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
//   - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
//   - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
//   - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
//   - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
//   - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
//   - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
//   - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
//
// 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
//
// 示例 2：
//
// 输入：n = 1
// 输出：0
// 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
//
// 示例 3：
//
// 输入：n = 2
// 输出：1
// 解释：有两个可能的数字 1 和 2 。
// - 你可以先猜 1 。
//   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
//   - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
//
// 最糟糕的情况下，你需要支付 $1 。
//
// 提示：
//
// 1 <= n <= 200
func getMoneyAmount(n int) int {
	dp := make([][]int, n+2)
	for i := range dp {
		dp[i] = make([]int, n+2)
		for j := i + 1; j < n+2; j++ {
			dp[i][j] = math.MaxInt32
		}
	}
	for l := 2; l <= n; l++ {
		for i := 1; i+l-1 <= n; i++ {
			j := i + l - 1
			for k := i; k <= j; k++ {
				dp[i][j] = min(dp[i][j], k+max(dp[i][k-1], dp[k+1][j]))
			}
		}
	}
	return dp[1][n]
}

/**
思路：本质是动态规划。不断缩短目标区间，在给定区间内枚举数字。基于分解子问题进行目标问题的推导。
DP数组及下标含义
- l：目标区间长度。
- i：区间起点。则区间终点 j = i + l - 1。
- k：猜测的数字
- dp[i][j]：区间范围为[i, i + l - 1]时，当猜测任一数字 k 时所需的最大花费。
因为依赖小区间推导出大区间，所以需要枚举区间长度，由小及大。而不能简单枚举区间范围 i 和 j。
举例：若仅先枚举 i，再枚举 j，则在计算 dp[1][4] 时可能需要用到 dp[2][4]，此时还未计算，无法得出正确值。


递推公式
for l IN [2, n]
	for i IN [1, n - l + 1]
		j = i + l - 1
		for k IN [i, j]
			dp[i][j] = min(dp[i][j], 			因要求最小现金数，这里取 min
				k								猜错时支付的现金
					+ max(						本轮无论如何猜，都需要取胜，所以这里应为最大现金
						dp[i][k - 1],			若反馈目标数字更小，则缩短区间至左侧
						dp[k + 1][j]			若反馈目标数字更大，则缩短区间至右侧
					)
				)


初始化
对于 i, j：
- 若 i < j，则初始化为 MaxInt32，方便后续取 min
- 若 i >= j，则初始化为 0，因为对于区间长度 <= 1的场景，至多猜测一次就能猜对，无需额外支付


遍历方向
从左到右，从上往下
*/

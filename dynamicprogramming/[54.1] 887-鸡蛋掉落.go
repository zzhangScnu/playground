package dynamicprogramming

import "math"

// 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
//
// 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
//
// 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎
// ，则可以在之后的操作中 重复使用 这枚鸡蛋。
//
// 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
//
// 示例 1：
//
// 输入：k = 1, n = 2
// 输出：2
// 解释：
// 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
// 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
// 如果它没碎，那么肯定能得出 f = 2 。
// 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
//
// 示例 2：
//
// 输入：k = 2, n = 6
// 输出：3
//
// 示例 3：
//
// 输入：k = 3, n = 14
// 输出：4
//
// 提示：
//
// 1 <= k <= 100
// 1 <= n <= 10⁴
func superEggDrop(k int, n int) int {
	memo := make(map[[2]int]int)
	var dp func(i, j int) int
	dp = func(i, j int) int {
		if i == 0 || j == 0 {
			return 0
		}
		if i == 1 {
			return j
		}
		if j == 1 {
			return 1
		}
		if res, ok := memo[[2]int{i, j}]; ok {
			return res
		}
		res := math.MaxInt
		for testFloor := 1; testFloor <= j; testFloor++ {
			res = min(res, max(dp(i-1, testFloor-1), dp(i, j-testFloor))+1)
			memo[[2]int{i, j}] = res
		}
		return res
	}
	return dp(k, n)
}

/**
DP数组及下标含义：
状态：剩余鸡蛋个数&待测试的楼层层数
解：恰好摔碎鸡蛋的楼层高度的最小操作次数

情况1：只有一个鸡蛋。因为鸡蛋数量有限，随机选取楼层测试的话，万一碎了就无法得出具体恰好摔碎鸡蛋的楼层了(应该在更下层)。所以只能从第一层开始逐层向上测试，最坏测试次数即为总楼层层数；
情况2：有多个鸡蛋。此时可以遍历所有楼层，基于每个楼层进行测试和择优。解空间可以表示为二叉树。

设有2个鸡蛋，6层楼：

							(  		            2, 6				)
				  第一层开始扔/		 		\第二层开始扔  ...   		\ 第六层开始扔
						碎/	 \未碎
第一层扔				(1, 0)	  (2, 5)
							碎/	\未碎
第二层扔					(1, 1)	 (2, 4)
	鸡蛋数--，向下测试，仅剩一层楼   鸡蛋数不变，向上测试，仍剩4层楼

因为在任何情况下都需要找到这个楼层，所以需要找到在从每一层楼开始测试的最坏情况，即二叉树中每个子树的高度。
并在所有的最坏情况中取最小次数，则为整体的最小次数。


- i：剩余i个鸡蛋，0 <= i <= k
- j：待测试楼层层数，0 <= j <= n
- dp[i][j]：对于剩余i个鸡蛋，在还有j层楼需要测试的情况下，能确认恰好摔碎鸡蛋的楼层的最小操作次数。

递推公式：
dp[i][j] = min(
		dp[i][j]
		max(碎了, 没碎) = min(dp[i-1][j-1], dp[i][n-j]) + 1
	)
注意，每个dp[i][j]都是独立计算j层楼的最优解，与这些楼层在建筑中的实际物理位置无关。
循环中的j范围[1, j]表示在当前j层范围内的相对位置。所以每个子问题都是从1到j的固定范围。

遍历方向：
由递推公式可知，i依赖于i-1，j依赖于j-1和n-j，故正向遍历即可。

初始化：
当i == 1，只有1个鸡蛋，只能从最底层逐层向上遍历，测试次数 == 总楼层高度；
当j == 1，只有一层楼，仅需测试一次，测试次数 == 1；
当i == 0 \\ j == 0，无需测试，测试次数 == 0。
*/

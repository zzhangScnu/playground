package dynamicprogramming

// 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
//
// 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
//
// 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎
// ，则可以在之后的操作中 重复使用 这枚鸡蛋。
//
// 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
//
// 示例 1：
//
// 输入：k = 1, n = 2
// 输出：2
// 解释：
// 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
// 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
// 如果它没碎，那么肯定能得出 f = 2 。
// 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
//
// 示例 2：
//
// 输入：k = 2, n = 6
// 输出：3
//
// 示例 3：
//
// 输入：k = 3, n = 14
// 输出：4
//
// 提示：
//
// 1 <= k <= 100
// 1 <= n <= 10⁴
func superEggDropIII(k int, n int) int {
	dp := make([][]int, k+1)
	for i := 0; i <= k; i++ {
		dp[i] = make([]int, n+1)
	}
	for i := 1; i <= k; i++ {
		for j := 1; j <= n; j++ {
			dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1
			if dp[k][j] >= n {
				return j
			}
		}
	}
	return -1
}

/**
DP数组及下标定义：
- i：鸡蛋个数
- j：能够尝试的最大次数
- dp[i][j]：能够测试的最大层数

递推公式：
dp[i][j] = 碎了&下方能够测试的最大层数 +  没碎&上方能够测试的最大层数 + 当前测试的楼层
		 = dp[i-1][j-1] + dp[i][j-1] + 1
当dp[k][j] >= n时，即拥有k个鸡蛋且能够测试的最大层数可覆盖所有楼层，首次到达的j即为最小操作数。

初始化：
可知：
i == 0时，dp[0][...] = 0
j == 0时，dp[...][0] = 0

遍历方向：
i&j依赖于i-1&j-1推导而来，故从左到右由上而下遍历。

整体时间复杂度 = 子问题复杂度 * 子问题个数
			= 递归函数复杂度 * 所有状态个数
			= 1 * (K * N)
			= O(KN)

可通过滚动数组优化空间复杂度。
*/

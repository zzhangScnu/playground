package dynamicprogramming

// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
//
// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
//
// 示例 1：
//
// 输入：n = 2
// 输出：2
// 解释：有两种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶
// 2. 2 阶
//
// 示例 2：
//
// 输入：n = 3
// 输出：3
// 解释：有三种方法可以爬到楼顶。
// 1. 1 阶 + 1 阶 + 1 阶
// 2. 1 阶 + 2 阶
// 3. 2 阶 + 1 阶
//
// 提示：
//
// 1 <= n <= 45
func climbStairs(n int) int {
	if n == 1 || n == 2 {
		return n
	}
	sum, dp2, dp1 := 0, 2, 1
	for i := 3; i <= n; i++ {
		sum = dp2 + dp1
		dp2, dp1 = sum, dp2
	}
	return sum
}

/**
- DP数组和下标的含义：dp[i] -> 爬到该处有几种不同的方法；i -> 此时处于第i阶
- 递归公式：dp[i] = dp[i - 2] + dp[i - 1]
  从高处回头看，如果要走到第i阶，要不一次爬1个台阶，要不一次爬2个台阶，
  所以爬到i阶的方法种数应该是【爬到i-2阶的方法种数】与【爬到i-1阶的方法种数】的和，即dp[i - 2] + 与dp[i - 1]
  这里要注意，求的是爬上来有几种方法，而不是爬了几个台阶，所以不存在求dp[i - 2] + 2 或 dp[i - 1] + 1
- DP数组初始化：dp[1] = 1，dp[2] = 2
  题目指定了n为正整数，所以dp[0]没有业务语义，可以忽略。
- 遍历方向：从左到右

实际上，这道题就是斐波那契数列，只是初始化值不同。
*/

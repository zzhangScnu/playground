package dynamicprogramming

//Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。
//
// 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。
//
// Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此
//时手中 石子最多 的玩家 获胜 。
//
// 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。
//
//
//
// 示例 1：
//
//
//输入：piles = [5,3,4,5]
//输出：true
//解释：
//Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
//假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
//如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
//如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
//这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
//
//
// 示例 2：
//
//
//输入：piles = [3,7,2,3]
//输出：true
//
//
//
//
// 提示：
//
//
// 2 <= piles.length <= 500
// piles.length 是 偶数
// 1 <= piles[i] <= 500
// sum(piles[i]) 是 奇数
//

func stoneGame(piles []int) bool {
	n := len(piles)
	dp := make([][][2]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([][2]int, n)
		dp[i][i][0], dp[0][0][1] = piles[i], 0
	}
	for i := n - 1; i >= 0; i-- {
		for j := i + 1; j < n; j++ {
			left, right := dp[i+1][j][1]+piles[i], dp[i][j-1][1]+piles[j]
			dp[i][j][0] = max(left, right)
			if left > right {
				dp[i][j][1] = dp[i+1][j][0]
			} else {
				dp[i][j][1] = dp[i][j-1][0]
			}
		}
	}
	return dp[0][n-1][0]-dp[0][n-1][1] > 0
}

/**
思路：

DP数组及下标(涉及状态)含义：
- i：石头堆中索引为i，0 <= i < n
- j：石头堆中索引为j，i <= j < n
- k：先手 0 / 后手 1，
- dp[i]][j][k]：在石头堆[i, j]范围中，先手/后手能取得的最大石头数。

递推公式：
每一轮分别以先手&后手的视角做出一轮选择：

left：当先手选择最左边的石头堆时，整体所能取得的最大石头数 ==
      本轮选择的最左边即索引为i的石堆中石头的数量 piles[i] +
      剩余石头堆范围[i+1, j]，且下一轮我作为后手，在对面选择后，我做出最优选择所能得到的最大石头数 dp[i+1][j][1]

	  dp[i+1][j][1]：当a作为先手本轮选择i时，剩余可选范围为[i+1, j]，此时后手b轮转为先手并选择最优，接着a变成后手继续选择，即dp[i+1][j][1]。
	  此时dp[i+1][j][1]已经覆盖了b的选择，无论选择最左后剩余[i+2, j]还是选择最右后剩余[i+1, j-1]，根据递推公式从下到上，从左到右遍历的特性，已经被计算在dp[i+1][j][1]中。


// 先手视角：
left, right := dp[i+1][j][1] + piles[i], dp[i][j-1][1] + piles[j]
dp[i][j][0] = max(left, right)
// 后手视角：
if left > right {
 	// 当先手在最左和最右中选取了最大的最左堆，留下了[i+1, j]让我选择，此时我成为相对的先手进行选择
    dp[i][j][1] = dp[i+1][j][0]
} else {
    dp[i][j][1] = dp[i][j-1][0]
}

遍历顺序&初始化：
由递推公式可知，i&j依赖于i+1&j-1推导而来，所以需要从下到上，从左到右遍历。
当只有一堆石头时，先手只有一种选择，即直接拿；后手也只有一种选择，即没得拿。
dp[i][i][0] = piles[i]
dp[i][i][1] = 0
*/

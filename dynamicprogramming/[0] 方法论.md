# 概念

- 贪心：每次选取局部最优，每次选取间是独立的，跟上个状态没有关系；
- 动态规划：从上一个状态推导下一个状态。

# 核心

- 适用场景：可以通过拆解子问题来求解。前提是子问题间必须互相独立
- 一般形式：求解最值，即通过穷举枚举可行解，并在其中取最优解
- 如何穷举
    - 状态转移方程：通过递归正确穷举
    - 最优子结构：通过子问题的最值推导原问题的最值，前提是子问题间必须相互独立
    - 重叠子问题：使用备忘录思想避免重复计算
- 什么是状态？
    - 例如要求f(N)的值，就需要通过分解原问题，由子问题f(N-1), ..., f(1)推导而来。子问题规模不断减小，不断接近base case
    - 期间，f函数的参数会不断变化，该参数即为「状态」
    - 状态N由其他状态计算而来，即状态转移
    - 常见形式：
        - 递归：f(N) = f(N-1) + f(N-1)
        - 迭代：dp[N] = dp[N-1] + dp[N-2]
- 状态压缩：若当前状态仅和特定的部分状态有关，如前两个状态，则不需要数组存储完整的所有状态，仅需压缩为几个必要的变量即可
- 什么是选择？
    - 选择是导致「状态」产生变化的行为
- 如何推导状态转移方程：<br>
  明确base case -> 明确状态 -> 明确选择 -> 定义DP数组 -> 定义递推公式<br>
- 时间复杂度：
    - 子问题个数 * 单个子问题所需时间
    - 画出递归树进行分析
        - 子问题个数 -> 递归树节点总数，通常为O(2^N)的指数级别
        - 单个子问题所需时间 -> 单个节点耗费时间
        - 是否有重叠子问题，是否可以通过备忘录剪枝，减少树的大小<br>
          通过去除冗余，将图中节点个数降低至输入规模，即时间复杂度为O(N)
- 代码框架

```
// 自顶向下递归的动态规划
// f(N) -> f(...) -> f(1)
// 存在重复子树，即重叠子问题，需要通过备忘录消除冗余
func dp(状态1, 状态2 int, 其他状态 ...int) int {
    result := 初始值
    for _, 选择 := range 所有可能的选择 {
        // 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(新状态1, 新状态2, 其他新状态...))
    }
    return result
}

// 自底向上迭代的动态规划
// f(1) -> f(...) -> f(N)
// 天然具备备忘录能力，不存在冗余
func iterativeDP() {
    // 初始化 base case
    dp := make([][]int, 状态1的最大值+1)
    for i := range dp {
        dp[i] = make([]int, 状态2的最大值+1)
    }
    dp[0][0] = baseCase // 初始化base case

    // 进行状态转移
    for 状态1 := 0; 状态1 <= 状态1的最大值; 状态1++ {
        for 状态2 := 0; 状态2 <= 状态2的最大值; 状态2++ {
            // 遍历所有状态组合
            dp[状态1][状态2] = 求最值(选择1, 选择2...)
        }
    }
}
```

# 解题思路

动态规划五部曲：

- 确定DP数组及下标含义：一维/二维，用作状态转移
- 确定递推公式
- 确定DP数组初始化方式
- 确定遍历顺序
- 举例推导DP数组、打印DP数组


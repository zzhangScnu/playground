package dynamicprogramming

// 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
//
// 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i -
// 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
//
// 求所能获得硬币的最大数量。
//
// 示例 1：
//
// 输入：nums = [3,1,5,8]
// 输出：167
// 解释：
// nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
// coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
//
// 示例 2：
//
// 输入：nums = [1,5]
// 输出：10
//
// 提示：
//
// n == nums.length
// 1 <= n <= 300
// 0 <= nums[i] <= 100
func maxCoins(nums []int) int {
	nums = append([]int{1}, append(nums, 1)...)
	n := len(nums)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, n)
	}
	for i := n - 1; i >= 0; i-- {
		for j := i; j < n; j++ {
			for k := i + 1; k < j; k++ {
				dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])
			}
		}
	}
	return dp[0][n-1]
}

/**
思路：
本题的难点在于如何将原问题拆解为独立子问题。
可以在气球序列头部和尾部各插入一个虚拟气球，对应越界气球 == 数字为1的气球。
[1, 气球1, ... 气球n, 1]，此时序列长度 n += 2。

因为戳破第i个气球，可获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。
有了头尾的虚拟气球，需将在其之间的所有气球戳破。
而最大值的计算和择优，需要穷举戳破气球顺序的所有可能性。

DP数组及下标含义：
- i：坐标为i的气球
- j：坐标为j的气球
- dp[i][j]：(i, j)开区间内的气球，全部戳破所能获得的最大硬币数量。

递推公式：
for 所有可能的(i, j)区间
	for 在(i, j)开区间中最后一个戳破的气球k
		dp[i][j] = max(
			dp[i][j],
			dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]
		)
即将区间划分为如下几个部分：
[ i ][ i + 1, k - 1 ][ k ] [ k + 1, j - 1][ j ]
最后戳破(i, j)开区间内的第k个气球所能获得的硬币数量 ==
	戳破(i, k)开区间内的所有气球所能获得的硬币数量 +
	戳破(k, j)开区间内的所有气球所能获得的硬币数量 +
	戳破以上两个子区间内的气球后，原区间内剩余第k个气球，此时戳破其所能获得的硬币数量 nums[i] * nums[k] * nums[j]

初始化：
当 i == j时，此时区间内真实气球数量为空，则结果为0。

遍历方向：
由递推公式可知，
dp[i][j] 依赖 dp[i][k] 和 dp[k][j] 推导而来，其中 k IN (i, j)开区间
且最终结果在dp[0][n - 1]，即为右上角。
所以需要从下往上、从左到右遍历。
*/

package divide_conquer

// 颠倒给定的 32 位无符号整数的二进制位。
//
// 提示：
//
// 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的
// 还是无符号的，其内部的二进制表示形式都是相同的。
// 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
//
// 示例 1：
//
// 输入：n = 00000010100101000001111010011100
// 输出：964176192 (00111001011110000010100101000000)
// 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
//
//	因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
//
// 示例 2：
//
// 输入：n = 11111111111111111111111111111101
// 输出：3221225471 (10111111111111111111111111111111)
// 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
//
//	因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
//
// 提示：
//
// 输入是一个长度为 32 的二进制字符串
//
// 进阶: 如果多次调用这个函数，你将如何优化你的算法？
func reverseBits(num uint32) uint32 {
	for i := 0; i < 16; i++ {
		left, right := num>>(31-i)&1, num>>i&1
		if left == right {
			continue
		}
		mask := 1<<(31-i) | 1<<i
		num ^= uint32(mask)
	}
	return num
}

func reverseBitsByMask(num uint32) uint32 {
	num = num>>16 | num<<16
	num = (num & 0xFF00FF00 >> 8) | (num & 0x00FF00FF << 8)
	num = (num & 0xF0F0F0F0 >> 4) | (num & 0x0F0F0F0F << 4)
	num = (num & 0xCCCCCCCC >> 2) | (num & 0x33333333 << 2)
	num = (num & 0xAAAAAAAA >> 1) | (num & 0x55555555 << 1)
	return num
}

/**
方案一：双指针
将两端的二进制位右移到最低位，通过跟1进行与操作分别提取出来，如果相等则跳过不处理。这步判断重要，若两端相同也走到下面的异或，则会同步取反。如1...1 -> 0...0。
否则定义一个掩码：只有本次要处理的两端的二进制位位1，其余位均为0，跟num进行异或来达到取反效果。
1 ^ 1 -> 0
0 ^ 1 -> 1

方案二：分治
第一轮处理-颠倒高16位和低16位：将高16位右移到低16位，低16位左移到高16位，原位置补0，再进行或操作；
第一轮处理-颠倒高16位中的高8位和低8位，低16位中的高8位和低8位：
- num与FF00FF00进行与操作，提取出每16位中的高8位，再整体右移8位，相当于移动到了低8位；
- num与00FF00FF进行与操作，提取出每16位中的低8位，再整体左移8位，相当于移动到了高8位；
- 将两次处理结果进行或操作，相当于合并结果。
再进行剩下的处理，直到完成两两交换。
*/

/**
优先级陷阱：异或运算符优先级较低，需注意加括号。
示例：a ^ b == c 应写为 (a ^ b) == c。
*/

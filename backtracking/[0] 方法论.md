# 回溯

## 框架

```
func backtrack(路径, 选择列表)
  if base case
    收获路径
    return
  for 选择列表
    选择
    backtrack(路径, 选择列表)
    撤销选择
```

backtrack函数就像一个指针游走在决策树上，同时正确维护节点属性。当走到叶子节点时，即寻找到了可行解。
单层逻辑就是一个决策节点，需要维护的属性有：<br>

- 路径：已做出的选择；
- 选择列表：当前可做的选择；
- 结束条件：到达决策树底层，无法继续做选择的条件。

## 核心

- 本质：遍历由问题抽象出来决策树，穷举可能性，寻找最优解；
- 选择：站在每个决策点上，根据约束条件、状态合法性等评估路径可行性，并通过剪枝降低决策树大小；
- 撤销选择：当不满足择优条件时，回到上一个决策点，以便选择其他路径，即回溯；
- 关注树枝：在抽象出来的决策树中，节点无实际语义，而路径代表可选项。回溯核心在于选择路径。
    - 所以选择/撤销选择放在for循环中。

## 思考

- 如果仅需找到一种可行解，怎么优化？<br>
  对backtrack方法增加bool返回值，当找到时直接返回true，阻断后续的回溯流程。

# DFS

## 框架

```
func dfs(节点)
  if 叶子节点
    return
  for 孩子节点列表
    dfs(孩子节点)
```

## 核心

- 本质：遍历实体图，访问所有节点；
- 选择：从起始节点出发，无脑选择所有孩子节点，尽可能深地进行下探；
- 撤销选择：
  当无法继续下探或到达目标节点时，回溯到上一个节点，以便选择其他孩子节点进行访问。
    - 有向图，即N叉树，单向性天然保障不会重复访问同一节点；
    - 无向图，由于存在多种访问路径选择，需要回溯。且需要visited数组辅助记录，避免重复访问导致死循环；
- 关注节点：在图中，节点代表实际元素，而路径仅表示节点间的联通和指向关系。DFS核心在于选择节点。
    - 所以选择/撤销选择放在for循环外，否则可能会导致根节点遗漏。

## 思考

- 为什么二叉树遍历无需回溯？<br>
  因为递归遍历时，由于系统栈会记录执行位置、当前节点状态等，具备隐式回溯能力，无需手动记录路径或回溯。
package tree

// 给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：
//
// 选择二叉树中 任意 节点和一个方向（左或者右）。
// 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
// 改变前进方向：左变右或者右变左。
// 重复第二步和第三步，直到你在树中无法继续移动。
//
// 交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。
//
// 请你返回给定树中最长 交错路径 的长度。
//
// 示例 1：
//
// 输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
// 输出：3
// 解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
//
// 示例 2：
//
// 输入：root = [1,1,1,null,1,null,null,1,1,null,1]
// 输出：4
// 解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
//
// 示例 3：
//
// 输入：root = [1]
// 输出：0
//
// 提示：
//
// 每棵树最多有 50000 个节点。
// 每个节点的值在 [1, 100] 之间。
func longestZigZag(root *TreeNode) int {
	var res int
	var traverse func(node *TreeNode, direction int) int // -1: left; 1: right
	traverse = func(node *TreeNode, direction int) int {
		if node == nil {
			return -1
		}
		if direction == -1 {
			left := traverse(node.Left, 1) + 1
			right := traverse(node.Right, -1) + 1
			res = max(res, left, right)
			return left
		} else {
			right := traverse(node.Right, -1) + 1
			left := traverse(node.Left, 1) + 1
			res = max(res, left, right)
			return right
		}
	}
	traverse(root, -1)
	traverse(root, 1)
	return res
}

/**
改进前后的代码在核心思路、路径处理逻辑和覆盖范围上有显著区别，主要体现在以下几个方面：


### 1. **核心思路不同**
- **原代码**：
  从根节点出发，固定初始方向（向左或向右），尝试沿“交替方向”延伸路径，仅在叶子节点更新最长路径长度。本质是“从根节点开始的两条固定路径探索”。

- **改进后代码**：
  以所有节点为潜在起点，通过递归探索每个节点在“向左延伸”和“向右延伸”两种方向下的最长路径，实时更新全局最大值。本质是“覆盖所有节点和所有可能起始方向的全面探索”。


### 2. **路径延伸逻辑不同**
- **原代码**：
  仅按当前方向强制延伸，若无法延伸（如当前方向要求向左但左孩子不存在），则直接终止路径，且不考虑“从当前节点反向重新开始”的情况。
  例如：若当前方向是向左，但左孩子不存在，原代码会直接结束，忽略“从当前节点向右开始新路径”的可能性。

- **改进后代码**：
  每个节点在处理时，会同时做两件事：
  1. 按当前要求的方向延伸（如要求向左，则递归左孩子，且下一次方向必须向右）；
  2. 从当前节点反向重新开始（如要求向左，但左孩子不存在时，尝试从当前节点向右开始新路径，下一次方向必须向左）。
  这种“延伸+重启”的逻辑确保了不会错过潜在的更长路径。


### 3. **终止条件与结果更新不同**
- **原代码**：
  仅在叶子节点（`node.Left == nil && node.Right == nil`）时才更新最长路径长度。这会漏掉“非叶子节点作为终点”的情况（如某节点有一个孩子，但方向不允许延伸，此时路径终止于该非叶子节点，可能是更长路径）。

- **改进后代码**：
  不依赖叶子节点判断终止，而是在每个节点处理时，实时比较“延伸路径”和“重启路径”的长度，并更新全局最大值。无论节点是否为叶子，只要当前路径无法继续延伸，其长度就会被纳入计算，避免遗漏。


### 4. **覆盖的路径范围不同**
- **原代码**：
  仅从根节点出发，尝试向左和向右两种初始方向，无法覆盖“从非根节点开始的路径”。例如，某棵树中最长路径可能从中间节点开始，但原代码会完全忽略。

- **改进后代码**：
  通过递归遍历所有节点，每个节点都会被作为“潜在起点”处理（递归过程中自然覆盖所有节点）。例如，中间节点的左/右孩子延伸出的路径，会被自动计算并更新到全局最大值中。


### 5. **返回值的意义不同**
- **原代码**：
  递归函数 `traverse` 无返回值，仅通过全局变量 `res` 记录结果，逻辑上是“单向探索”。

- **改进后代码**：
  递归函数 `dfs` 有明确返回值：表示“从当前节点按指定方向延伸的最长路径长度”。这个返回值会被父节点用于计算更长的路径（父节点可以基于子节点的结果继续延伸），形成“自底向上”的动态规划式计算，效率更高。


### 总结对比表
| 维度               | 原代码                     | 改进后代码                 |
|--------------------|---------------------------|---------------------------|
| 起点覆盖           | 仅根节点                  | 所有节点                  |
| 方向处理           | 仅按当前方向延伸，不重启  | 延伸+反向重启             |
| 结果更新时机       | 仅叶子节点                | 每个节点处理时            |
| 返回值作用         | 无返回值                  | 供父节点延伸路径          |
| 路径完整性         | 可能遗漏非根起点、非叶子终点路径 | 覆盖所有可能路径          |


简言之，原代码是“局部探索”，而改进后代码是“全局探索”，通过更灵活的路径处理逻辑和更全面的覆盖范围，确保能找到真正的最长 zigzag 路径。
*/

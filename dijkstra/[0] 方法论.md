# 概念

# 算法核心

- BFS
- 推演逻辑
    - 二叉树层序遍历：对每个节点遍历左右子节点。step记录层数，外层for控制纵向扩展+内层for控制横向遍历；
    - 多叉树层序遍历：二叉树层序遍历 + 对每个节点for循环遍历子节点；
    - 广度优先搜索：多叉树层序遍历 + visited辅助数组防止无向图节点重复访问 + for循环遍历相邻节点。<br>
      对于无权图，边的权重均为1，从起点到任意节点的路径权重 == 边的条数 == step。
    - Dijkstra：
      对于加权图，边的权重为任意**正数**，需考虑路径的权重之和。<br>
      而step是逐步向外扩散的步数，故需对step的维护逻辑进行改造。<br>
      即去掉内层for循环 + 记录各节点的**起点到自身最短路径的权重和**。<br>
      所以Dijkstra == BFS + 备忘录。

# 求解方向

- 返回从起点到其他所有节点的最短路径权重数组；
- 返回从起点到某个终点的最短路径权重。

# 详解

- 节点重复访问问题：
    - BFS：通过visited节点控制每个节点只能访问一次；
    - Dijkstra：同一个节点可能通过不同路径访问多次，从而找到最短路径及其权重。<br>
      如 [0, 1, 1], [1, 2, 1], [0, 2, 5]，需要访问节点2两次才能找到0 -> 2的最短路径，即0 -> 1 -> 2。<br>
      但因为最短路径是确定且唯一的，循环一定会收敛到base case从而终止，不会陷入无限循环。
- 核心：
    - 结果集distance：distance[i]表示从起点start到节点i的最短路径的权重。<br>
      初始化：distance[start] = 0，其他赋值math.MaxInt，便于后续动态取最小权重和。<br>
    - 优先级队列：每次取出从起点开始的路径中最小权重和对应的节点，进行最小路径计算和更新。<br>
      体现了贪心思想，较小权重和的子路径更有可能成为整体最短路径的一部分。
- 如何仅计算从起点到某个终点的最短路径权重：
    - 从队列中取出节点，发现已到达终点则直接返回；
    - 因为BFS的扩散特性，结合贪心思想，第一次到达终点时的路径就是最优的。

# 时间复杂度分析

O(ElogV)：

- 优先级队列最多容纳V个节点；
- 对优先级队列的操作次数与E成正比。
    


package bitwise

// 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。
//
// 示例 1：
//
// 输入：n = 10
// 输出：4
// 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
//
// 示例 2：
//
// 输入：n = 0
// 输出：0
//
// 示例 3：
//
// 输入：n = 1
// 输出：0
//
// 提示：
//
// 0 <= n <= 5 * 10⁶
func countPrimes(n int) int {
	primes := make([]int, n)
	for i := 2; i*i < n; i++ {
		for j := i * i; j < n; j = j + i {
			primes[j] = 1
		}
	}
	var count int
	for i := 2; i < n; i++ {
		if primes[i] == 0 {
			count++
		}
	}
	return count
}

/**
思路：
普通判断质数的做法：
func isPrime(num int) bool {
	for i := 2; i*i < num; i++ {
		if num%i == 0 {
			return false
		}
	}
	return true
}
循环终止条件为 i*i < num 的原因是：
如 8 = 2 * 4 = 4 * 2，在越过Sqrt(num)以后，会存在重复的整除因子组合。
所以判断到Sqrt(num)即可。

回到题目，如果对给出的[2, n)范围内的所有元素进行以上判断，
时间复杂度为O(n^2)且存在大量冗余计算。

此时引入一种新的思路：排除法。
如对于素数2，2 * 2、2 * 3、2 * 4 … 都不可能是素数。
即对于每一个元素num，可排除后续不可能是素数的元素，即将num的整数倍都排除。
在将所有不可能的元素排除完毕后，再遍历数组收割结果。

for i := 2; i*i < n; i++ {
	for j := i * i; j < n; j = j + i {

	}
}
其中对于循环条件，可以进行优化：
- 外层循环：通过前面的分析可知，由于整除因子的对称性，仅需对 [2, Sqrt(n)] 范围内的数 num 及 num的整数倍的数进行排除。这些已经包含了Sqrt(n)之后的数，不会遗漏；
- 内层循环：例如 i = 5 时，会标记 5 * 2、5 * 3等，但这两个数字已经被 i = 2 的 2 * 5 和 i = 3 时的 3 * 5 标记过了。
  		  所以内层仅需从 5 * 5 即 i * i 开始。
*/

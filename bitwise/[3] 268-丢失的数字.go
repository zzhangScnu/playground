package bitwise

// 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
//
// 示例 1：
//
// 输入：nums = [3,0,1]
//
// 输出：2
//
// 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
//
// 示例 2：
//
// 输入：nums = [0,1]
//
// 输出：2
//
// 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
//
// 示例 3：
//
// 输入：nums = [9,6,4,2,3,5,7,0,1]
//
// 输出：8
//
// 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
//
// 提示：
//
// n == nums.length
// 1 <= n <= 10⁴
// 0 <= nums[i] <= n
// nums 中的所有数字都 独一无二
//
// 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
func missingNumber(nums []int) int {
	n := len(nums)
	var sum int
	for i := 0; i <= n; i++ {
		sum += i
	}
	for _, num := range nums {
		sum -= num
	}
	return sum
}

func missingNumberII(nums []int) int {
	n := len(nums)
	var res int
	res ^= n
	for index, num := range nums {
		res ^= index ^ num
	}
	return res
}

/**
思路一
- 计算全集元素的和，即[0, n]范围内的所有元素；
- 减去已知元素，即nums中的元素；
- 剩余的即为缺失的元素。

思路二：
元素范围为[0, n]，长度为 n
nums 对应索引范围为[0, n - 1]，长度为 n - 1

所以如果对nums补齐一位，令其长度为 n，则其索引范围为[0, n]，
但元素范围为[0, n - 1]。
在元素装满的情况下，元素和索引成对出现、一一映射且相等。
由异或操作可知：
- 相同数异或归零
- 任何数与0异或不变

所以通过对 nums 中的元素不断计算 res ^= index ^ num，
一定会有一个元素落单，无法与已有的索引进行匹配消除。
该元素即为缺失元素。
*/
